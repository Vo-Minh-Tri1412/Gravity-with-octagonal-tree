\documentclass[12pt, a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[vietnamese]{babel}
\usepackage{amsmath, amsfonts, amssymb}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}
\usepackage{tabularx}
\usepackage{enumitem}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{tcolorbox}
\usepackage{fontawesome5}

% Cấu hình trang
\geometry{
    left=25mm,
    right=20mm,
    top=25mm,
    bottom=25mm
}

% Cấu hình hiển thị code C++
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    morekeywords={nullptr, override, constexpr, noexcept}
}
\lstset{style=mystyle}

% Custom tcolorbox styles
\tcbuselibrary{skins,breakable}
\newtcolorbox{importantbox}{
    colback=red!5!white,
    colframe=red!75!black,
    fonttitle=\bfseries,
    title=\faExclamationTriangle\ Quan trọng,
    breakable
}

\newtcolorbox{tipbox}{
    colback=green!5!white,
    colframe=green!75!black,
    fonttitle=\bfseries,
    title=\faLightbulb\ Mẹo,
    breakable
}

\newtcolorbox{conceptbox}{
    colback=blue!5!white,
    colframe=blue!75!black,
    fonttitle=\bfseries,
    breakable
}

% Thông tin trang bìa
\title{
    \textbf{\LARGE ĐẠI HỌC QUỐC GIA TP.HCM}\\
    \textbf{\Large TRƯỜNG ĐẠI HỌC KHOA HỌC TỰ NHIÊN}\\
    \textbf{\Large KHOA CÔNG NGHỆ THÔNG TIN}\\
    \vspace{2cm}
    \textbf{\Huge ZERO-TO-HERO PROJECT GUIDE}\\
    \vspace{0.5cm}
    \textbf{\LARGE CẤU TRÚC DỮ LIỆU VÀ GIẢI THUẬT}\\
    \vspace{1.5cm}
    \textbf{\LARGE ĐỀ TÀI:}\\
    \textbf{\huge MÔ PHỎNG VŨ TRỤ 3D (N-BODY SIMULATION)}\\
    \textbf{\Large THUẬT TOÁN BARNES-HUT VÀ CẤU TRÚC OCTREE}\\
    \vspace{2cm}
}
\author{
    \textbf{Nhóm thực hiện:} [Tên Nhóm Của Bạn] \\
    \textbf{Thành viên:} \\
    1. [Tên thành viên 1] - Trưởng nhóm (Algorithm Lead) \\
    2. [Tên thành viên 2] - Physics \& Math Lead \\
    3. [Tên thành viên 3] - Graphics \& Optimization Lead \\
    \vspace{1cm} \\
    \textbf{Giảng viên hướng dẫn:} [Tên Giảng Viên]
}
\date{Học kỳ 2 - Năm học 2025-2026}

\begin{document}

\maketitle
\tableofcontents
\newpage

% =============================================================================
% PART I: INTRODUCTION AND OVERVIEW
% =============================================================================
\part{Tổng quan và Mục tiêu Dự án}

\chapter{Giới thiệu Bài toán N-Body}

\section{Bài toán N-Body là gì?}
Bài toán N-Body là bài toán \textbf{kinh điển} trong vật lý tính toán và thiên văn học. Mục tiêu là mô phỏng sự tương tác hấp dẫn giữa $N$ vật thể (thiên thể, hạt, hoặc ngôi sao) trong không gian 3D.

\begin{conceptbox}[title=\faRocket\ Ứng dụng thực tế]
    \begin{itemize}
        \item \textbf{Thiên văn học:} Mô phỏng sự hình thành thiên hà, va chạm giữa các thiên hà
        \item \textbf{Vật lý hạt:} Mô phỏng plasma, động lực học phân tử
        \item \textbf{Game Development:} Hệ thống particle nâng cao, hiệu ứng vũ trụ
        \item \textbf{Machine Learning:} Graph Neural Networks cho physical simulation
    \end{itemize}
\end{conceptbox}

\section{Vấn đề với Brute-Force}
Với phương pháp tính toán trực tiếp (Brute-force), mỗi vật thể phải tính lực tác dụng từ \textbf{tất cả} $(N-1)$ vật thể còn lại:

\begin{equation}
    \text{Số phép tính} = N \times (N-1) = N^2 - N \approx O(N^2)
\end{equation}

\begin{table}[H]
    \centering
    \caption{So sánh hiệu năng theo số lượng hạt}
    \begin{tabular}{|c|c|c|c|}
        \hline
        \textbf{Số hạt $N$} & \textbf{Brute-force $O(N^2)$} & \textbf{Barnes-Hut $O(N\log N)$} & \textbf{Tăng tốc} \\
        \hline
        1,000               & 1,000,000                     & 10,000                           & 100x              \\
        10,000              & 100,000,000                   & 133,000                          & 750x              \\
        100,000             & 10,000,000,000                & 1,660,000                        & 6,000x            \\
        \hline
    \end{tabular}
\end{table}

\begin{importantbox}
    Với $N = 10,000$ và FPS mục tiêu = 60, Brute-force cần tính $6 \times 10^9$ phép tính/giây.
    Đây là \textbf{không khả thi} với CPU thông thường!
\end{importantbox}

\section{Giải pháp: Thuật toán Barnes-Hut}
Năm 1986, Josh Barnes và Piet Hut công bố thuật toán giảm độ phức tạp xuống $O(N \log N)$ bằng cách sử dụng \textbf{cấu trúc dữ liệu cây} (Octree cho 3D).

\textbf{Ý tưởng cốt lõi:} Nếu một cụm sao ở \textit{đủ xa}, ta có thể coi cả cụm đó như \textbf{một điểm khối lượng duy nhất} đặt tại trọng tâm.

\section{Mục tiêu của Đồ án}
\begin{enumerate}
    \item \textbf{Mục tiêu kỹ thuật:}
          \begin{itemize}
              \item Cài đặt Octree và thuật toán Barnes-Hut từ đầu bằng C++
              \item Đạt hiệu năng real-time với $N \geq 10,000$ hạt
              \item Tích hợp đồ họa 3D với Raylib
          \end{itemize}

    \item \textbf{Mục tiêu học tập:}
          \begin{itemize}
              \item Nắm vững Con trỏ (Pointers) và Quản lý bộ nhớ động
              \item Hiểu sâu Đệ quy (Recursion) qua Tree traversal
              \item Phân tích độ phức tạp thuật toán (Big-O)
          \end{itemize}

    \item \textbf{Mục tiêu mở rộng (nếu còn thời gian):}
          \begin{itemize}
              \item Tối ưu hóa với OpenMP (Parallel Computing)
              \item Hiệu ứng đồ họa nâng cao (Bloom, Trails)
          \end{itemize}
\end{enumerate}

% =============================================================================
% PART II: ACCELERATED LEARNING PATH
% =============================================================================
\part{Lộ trình Học tập Cấp tốc (Just-in-Time Learning)}

\chapter{Pointers \& Memory Management}

\section{Tại sao Con trỏ quan trọng cho Octree?}
Octree là cấu trúc dữ liệu \textbf{đệ quy} - mỗi node có thể chứa tối đa 8 node con. Để biểu diễn mối quan hệ này, ta \textbf{bắt buộc} phải dùng con trỏ.

\begin{importantbox}
    Nếu không hiểu con trỏ, bạn sẽ gặp:
    \begin{itemize}
        \item \textbf{Segmentation Fault:} Truy cập vùng nhớ không hợp lệ
        \item \textbf{Memory Leak:} Quên giải phóng bộ nhớ, chương trình ngốn RAM
        \item \textbf{Dangling Pointer:} Trỏ đến vùng nhớ đã bị xóa
    \end{itemize}
\end{importantbox}

\section{Kiến thức cần nắm}

\subsection{Con trỏ cơ bản}
\begin{lstlisting}[language=C++, caption=Pointer Basics]
// 1. Khai bao con tro
int x = 10;
int* ptr = &x;  // ptr LUU DIA CHI cua x

// 2. Truy cap gia tri qua con tro (Dereference)
int value = *ptr;  // value = 10

// 3. nullptr - con tro khong tro den dau ca
int* safePtr = nullptr;  // LUON khoi tao con tro = nullptr

// 4. Kiem tra truoc khi dung
if (ptr != nullptr) {
    *ptr = 20;  // An toan
}
\end{lstlisting}

\subsection{Dynamic Memory (Heap vs Stack)}
\begin{lstlisting}[language=C++, caption=Dynamic Memory Allocation]
// STACK: Tu dong giai phong khi ra khoi scope
void stackExample() {
    int arr[100];  // 100 int tren Stack
}  // arr tu dong mat khi ham ket thuc

// HEAP: Phai TU TAY giai phong
void heapExample() {
    // Cap phat 1 object
    int* single = new int(42);
    
    // Cap phat mang
    int* arr = new int[1000];
    
    // !!! PHAI GIAI PHONG !!!
    delete single;      // Xoa 1 object
    delete[] arr;       // Xoa mang (chu y [])
}
\end{lstlisting}

\begin{tipbox}
    \textbf{Quy tắc vàng:} Mỗi \texttt{new} phải có một \texttt{delete} tương ứng!

    Trong Modern C++, ưu tiên dùng \texttt{std::unique\_ptr} hoặc \texttt{std::shared\_ptr} để tự động quản lý bộ nhớ.
\end{tipbox}

\subsection{Con trỏ trong Struct/Class}
\begin{lstlisting}[language=C++, caption=Pointers in OctreeNode]
// Day la ly do Octree can con tro
struct OctreeNode {
    // Moi node co the co 8 con
    // Neu dung object truc tiep -> VO HAN (infinite recursion)
    // OctreeNode children[8];  // LOI! Khong the dinh nghia
    
    // Phai dung CON TRO
    OctreeNode* children[8];  // OK! Chi luu DIA CHI
    
    OctreeNode() {
        // Khoi tao tat ca con tro = nullptr
        for (int i = 0; i < 8; i++) {
            children[i] = nullptr;
        }
    }
    
    ~OctreeNode() {
        // Destructor: Giai phong tat ca node con (DE QUY!)
        for (int i = 0; i < 8; i++) {
            if (children[i] != nullptr) {
                delete children[i];  // Goi destructor cua con
                children[i] = nullptr;
            }
        }
    }
};
\end{lstlisting}

\section{Bài tập thực hành}
\begin{enumerate}
    \item Viết một Linked List đơn giản với các thao tác: \texttt{insert}, \texttt{remove}, \texttt{print}
    \item Viết Binary Search Tree với: \texttt{insert}, \texttt{search}, \texttt{inorderTraversal}
    \item Đảm bảo không có memory leak bằng cách chạy Valgrind (Linux) hoặc Visual Studio Memory Profiler
\end{enumerate}

% -----------------------------------------------------------------------------
\chapter{Recursion (Đệ quy)}

\section{Đệ quy là gì và tại sao cần cho Octree?}

\begin{conceptbox}[title=\faCode\ Định nghĩa Đệ quy]
    Đệ quy là kỹ thuật trong đó một hàm \textbf{tự gọi chính nó} với input nhỏ hơn cho đến khi đạt \textbf{điều kiện dừng} (base case).
\end{conceptbox}

\textbf{Octree dùng đệ quy ở đâu?}
\begin{enumerate}
    \item \textbf{Insert:} Khi chèn body vào cây, nếu node đã có body, ta chia node thành 8 con và chèn đệ quy.
    \item \textbf{ComputeMass:} Tính tổng khối lượng từ lá lên gốc (bottom-up).
    \item \textbf{CalculateForce:} Duyệt cây từ gốc, quyết định đi sâu hay xấp xỉ.
    \item \textbf{Destructor:} Xóa cây từ gốc, đệ quy xóa tất cả con.
\end{enumerate}

\section{Cấu trúc của hàm đệ quy}
\begin{lstlisting}[language=C++, caption=Anatomy of Recursion]
void recursiveFunction(Input input) {
    // 1. BASE CASE - Dieu kien dung
    //    Khong co base case = STACK OVERFLOW!
    if (/* dieu kien dung */) {
        return;  // hoac return gia tri
    }
    
    // 2. RECURSIVE CASE - Xu ly va goi lai chinh minh
    //    Input PHAI nho hon de tien ve base case
    recursiveFunction(smallerInput);
}

// Vi du: Tinh giai thua
int factorial(int n) {
    // Base case
    if (n <= 1) return 1;
    
    // Recursive case: n! = n * (n-1)!
    return n * factorial(n - 1);
}
\end{lstlisting}

\section{Đệ quy duyệt cây (Tree Traversal)}
\begin{lstlisting}[language=C++, caption=Tree Traversal Methods]
struct TreeNode {
    int value;
    TreeNode* left;
    TreeNode* right;
};

// Pre-order: Xu ly node TRUOC khi xuong con
// Dung cho: In cay, copy cay
void preorder(TreeNode* node) {
    if (node == nullptr) return;  // Base case
    
    process(node);           // Xu ly truoc
    preorder(node->left);    // Xuong trai
    preorder(node->right);   // Xuong phai
}

// Post-order: Xu ly node SAU khi xuong con
// Dung cho: Tinh toan tu duoi len (Center of Mass!)
void postorder(TreeNode* node) {
    if (node == nullptr) return;  // Base case
    
    postorder(node->left);   // Xuong trai truoc
    postorder(node->right);  // Xuong phai
    process(node);           // Xu ly SAU CUNG
}

// In-order: Trai -> Node -> Phai (cho BST)
void inorder(TreeNode* node) {
    if (node == nullptr) return;
    inorder(node->left);
    process(node);
    inorder(node->right);
}
\end{lstlisting}

\begin{importantbox}
    \textbf{Octree dùng Post-order} để tính Center of Mass!

    Lý do: Phải biết khối lượng của tất cả node con \textbf{trước} khi tính khối lượng của node cha.
\end{importantbox}

\section{Ví dụ: Đệ quy trong Octree}
\begin{lstlisting}[language=C++, caption=Recursive Mass Computation]
void OctreeNode::computeMassDistribution() {
    // BASE CASE 1: Node rong
    if (isExternal && body == nullptr) {
        totalMass = 0.0;
        return;
    }
    
    // BASE CASE 2: La (External node) co body
    if (isExternal && body != nullptr) {
        totalMass = body->mass;
        centerOfMass = body->pos;
        return;
    }
    
    // RECURSIVE CASE: Node trong (Internal node)
    // Buoc 1: Tinh khoi luong cua tat ca con truoc
    for (int i = 0; i < 8; i++) {
        if (children[i] != nullptr) {
            children[i]->computeMassDistribution();  // DE QUY!
        }
    }
    
    // Buoc 2: Tong hop tu cac con
    totalMass = 0.0;
    centerOfMass = Vec3(0, 0, 0);
    
    for (int i = 0; i < 8; i++) {
        if (children[i] != nullptr && children[i]->totalMass > 0) {
            double childMass = children[i]->totalMass;
            Vec3 childCOM = children[i]->centerOfMass;
            
            // Cong thuc trong tam: COM = sum(m_i * r_i) / sum(m_i)
            centerOfMass = centerOfMass + childCOM * childMass;
            totalMass += childMass;
        }
    }
    
    if (totalMass > 0) {
        centerOfMass = centerOfMass / totalMass;
    }
}
\end{lstlisting}

% -----------------------------------------------------------------------------
\chapter{Octree Data Structure}

\section{Khái niệm Octree}

\begin{conceptbox}[title=\faCubes\ Octree là gì?]
    Octree (Cây Bát phân) là cấu trúc dữ liệu cây dùng để \textbf{phân hoạch không gian 3D}.

    Mỗi node đại diện cho một \textbf{hình lập phương} (cube) và có thể chia thành \textbf{8 hình lập phương con} (octants).
\end{conceptbox}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=0.8]
        % Root cube
        \draw[thick] (0,0) rectangle (4,4);
        \node at (2,2) {Root};

        % Arrow
        \draw[->, thick] (4.5,2) -- (5.5,2);

        % Subdivided
        \draw[thick] (6,0) rectangle (10,4);
        \draw[thick] (8,0) -- (8,4);
        \draw[thick] (6,2) -- (10,2);

        \node[font=\tiny] at (7,3) {NW};
        \node[font=\tiny] at (9,3) {NE};
        \node[font=\tiny] at (7,1) {SW};
        \node[font=\tiny] at (9,1) {SE};

        \node[below] at (2,0) {Trước chia};
        \node[below] at (8,0) {Sau chia (2D: Quadtree)};
    \end{tikzpicture}
    \caption{Minh họa phân chia không gian (2D cho đơn giản)}
\end{figure}

\section{8 Octants trong 3D}
Mỗi octant được xác định bởi vị trí tương đối với tâm của node cha:

\begin{table}[H]
    \centering
    \caption{8 Octants và điều kiện xác định}
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{Index} & \textbf{Tên}      & \textbf{X}    & \textbf{Y}    & \textbf{Z}    \\
        \hline
        0              & Bottom-South-West & $<$ center    & $<$ center    & $<$ center    \\
        1              & Bottom-South-East & $\geq$ center & $<$ center    & $<$ center    \\
        2              & Bottom-North-West & $<$ center    & $\geq$ center & $<$ center    \\
        3              & Bottom-North-East & $\geq$ center & $\geq$ center & $<$ center    \\
        4              & Top-South-West    & $<$ center    & $<$ center    & $\geq$ center \\
        5              & Top-South-East    & $\geq$ center & $<$ center    & $\geq$ center \\
        6              & Top-North-West    & $<$ center    & $\geq$ center & $\geq$ center \\
        7              & Top-North-East    & $\geq$ center & $\geq$ center & $\geq$ center \\
        \hline
    \end{tabular}
\end{table}

\begin{lstlisting}[language=C++, caption=Calculate Octant Index]
// Tinh chi so octant (0-7) cho mot diem
int getOctantIndex(const Vec3& point, const Vec3& nodeCenter) {
    int index = 0;
    
    // Bit 0: X >= center.x
    if (point.x >= nodeCenter.x) index |= 1;
    
    // Bit 1: Y >= center.y  
    if (point.y >= nodeCenter.y) index |= 2;
    
    // Bit 2: Z >= center.z
    if (point.z >= nodeCenter.z) index |= 4;
    
    return index;  // Ket qua: 0 den 7
}
\end{lstlisting}

\section{Hai loại Node trong Octree}

\begin{enumerate}
    \item \textbf{External Node (Lá):}
          \begin{itemize}
              \item Không có node con
              \item Chứa \textbf{tối đa 1 body} (hoặc rỗng)
              \item Đây là điểm dừng của đệ quy
          \end{itemize}

    \item \textbf{Internal Node (Trong):}
          \begin{itemize}
              \item Có ít nhất 1 node con
              \item \textbf{Không chứa body trực tiếp}
              \item Lưu trữ \texttt{totalMass} và \texttt{centerOfMass} (tổng hợp từ con)
          \end{itemize}
\end{enumerate}

% -----------------------------------------------------------------------------
\chapter{Big-O Notation và Phân tích Độ phức tạp}

\section{Big-O là gì?}
Big-O notation mô tả \textbf{tốc độ tăng trưởng} của thời gian chạy hoặc bộ nhớ khi input tăng.

\begin{table}[H]
    \centering
    \caption{Các độ phức tạp phổ biến}
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Big-O} & \textbf{Tên} & \textbf{Ví dụ}                           \\
        \hline
        $O(1)$         & Constant     & Truy cập array bằng index                \\
        $O(\log N)$    & Logarithmic  & Binary Search                            \\
        $O(N)$         & Linear       & Duyệt mảng 1 lần                         \\
        $O(N \log N)$  & Linearithmic & \textbf{Barnes-Hut}, Merge Sort          \\
        $O(N^2)$       & Quadratic    & \textbf{Brute-force N-Body}, Bubble Sort \\
        $O(2^N)$       & Exponential  & Brute-force Traveling Salesman           \\
        \hline
    \end{tabular}
\end{table}

\section{Tại sao Barnes-Hut là $O(N \log N)$?}

\textbf{Phân tích:}
\begin{enumerate}
    \item \textbf{Xây dựng Octree:} Chèn $N$ body, mỗi lần chèn đi qua $O(\log N)$ mức $\Rightarrow O(N \log N)$

    \item \textbf{Tính lực cho 1 body:} Duyệt cây, trung bình thăm $O(\log N)$ node (vì nhiều cụm được xấp xỉ)

    \item \textbf{Tính lực cho $N$ body:} $N \times O(\log N) = O(N \log N)$
\end{enumerate}

\begin{tipbox}
    Với $N = 10,000$:
    \begin{itemize}
        \item $O(N^2) = 100,000,000$ operations
        \item $O(N \log N) \approx 10,000 \times 13.3 = 133,000$ operations
        \item \textbf{Tăng tốc: 750 lần!}
    \end{itemize}
\end{tipbox}

\section{So sánh trực quan}
\begin{lstlisting}[language=C++, caption=Brute-force vs Barnes-Hut]
// BRUTE-FORCE: O(N^2)
// Moi body phai xet TAT CA body khac
for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {  // N iterations
        if (i != j) {
            bodies[i].force += calculatePairForce(bodies[i], bodies[j]);
        }
    }
}
// Tong: N * N = N^2 lan tinh

// BARNES-HUT: O(N log N)
// Moi body chi xet ~log(N) "cum"
for (int i = 0; i < N; i++) {
    // calculateForce duyet cay, nhieu node duoc SKIP
    bodies[i].force = root->calculateForce(&bodies[i], theta);
}
// Trung binh: N * log(N) lan tinh
\end{lstlisting}

% =============================================================================
% PART III: 8-WEEK AGILE ROADMAP
% =============================================================================
\part{Lộ trình 8 Tuần (Agile Sprints)}

\chapter{Sprint Planning Overview}

\begin{table}[H]
    \centering
    \caption{Tổng quan 8 Tuần}
    \begin{tabularx}{\textwidth}{|c|X|X|}
        \hline
        \textbf{Tuần} & \textbf{Focus}         & \textbf{Sunday Milestone}                \\
        \hline
        1             & Setup \& C++ Basics    & Cửa sổ Raylib với hình lập phương quay   \\
        2             & Brute-Force Physics    & 500 sao di chuyển theo hấp dẫn           \\
        3             & Octree Structure       & Khung dây Octree hiển thị trên màn hình  \\
        4             & Octree Insert \& Mass  & Debug: In totalMass == sum of all bodies \\
        5             & Barnes-Hut Force       & 5,000 sao chạy real-time với BH          \\
        6             & Optimization \& Polish & 10,000 sao + FPS stable > 30             \\
        7             & Visual Effects         & Màu sao theo khối lượng + Camera smooth  \\
        8             & Report \& Demo         & Video demo + Báo cáo hoàn chỉnh          \\
        \hline
    \end{tabularx}
\end{table}

% -----------------------------------------------------------------------------
\chapter{Week 1: Environment Setup \& Raylib Basics}

\section{Focus: Môi trường phát triển và Đồ họa 3D cơ bản}

\subsection{Tasks}
\begin{enumerate}
    \item \textbf{Cài đặt môi trường:}
          \begin{itemize}
              \item Visual Studio 2022 hoặc VS Code + MinGW
              \item Raylib 4.5+ (download từ raylib.com)
              \item Git để quản lý version
          \end{itemize}

    \item \textbf{Học Raylib basics:}
          \begin{itemize}
              \item \texttt{InitWindow()}, \texttt{CloseWindow()}
              \item \texttt{BeginDrawing()}, \texttt{EndDrawing()}
              \item \texttt{Camera3D} và điều khiển camera
          \end{itemize}

    \item \textbf{Code \texttt{Vec3} struct} với operator overloading

    \item \textbf{Vẽ hình 3D cơ bản:} Cube, Sphere
\end{enumerate}

\subsection{Milestone: Spinning Cube}
\begin{lstlisting}[language=C++, caption=Week 1 Milestone - main.cpp]
#include "raylib.h"

int main() {
    // Khoi tao cua so 1280x720
    InitWindow(1280, 720, "N-Body Simulation - Week 1");
    SetTargetFPS(60);
    
    // Thiet lap Camera 3D
    Camera3D camera = { 0 };
    camera.position = (Vector3){ 10.0f, 10.0f, 10.0f };
    camera.target = (Vector3){ 0.0f, 0.0f, 0.0f };
    camera.up = (Vector3){ 0.0f, 1.0f, 0.0f };
    camera.fovy = 45.0f;
    camera.projection = CAMERA_PERSPECTIVE;
    
    float rotation = 0.0f;
    
    while (!WindowShouldClose()) {
        // Update
        rotation += 1.0f;
        UpdateCamera(&camera, CAMERA_ORBITAL);  // Cho phep xoay camera bang chuot
        
        // Draw
        BeginDrawing();
            ClearBackground(BLACK);
            
            BeginMode3D(camera);
                // Ve hinh lap phuong quay
                DrawCubeWires((Vector3){0, 0, 0}, 2.0f, 2.0f, 2.0f, GREEN);
                DrawGrid(10, 1.0f);
            EndMode3D();
            
            DrawText("Week 1: 3D Cube Spinning!", 10, 10, 20, WHITE);
            DrawFPS(10, 40);
        EndDrawing();
    }
    
    CloseWindow();
    return 0;
}
\end{lstlisting}

\textbf{Kết quả mong đợi:} Một cửa sổ đen với lưới và hình lập phương wireframe. Có thể xoay camera bằng chuột.

% -----------------------------------------------------------------------------
\chapter{Week 2: Brute-Force N-Body Implementation}

\section{Focus: Vật lý cơ bản và Brute-Force Algorithm}

\subsection{Tasks}
\begin{enumerate}
    \item \textbf{Implement \texttt{Body} struct:}
          \begin{itemize}
              \item Position, Velocity, Acceleration, Mass
              \item Hàm \texttt{update(dt)} để cập nhật vị trí
          \end{itemize}

    \item \textbf{Implement Newton's Gravity:}
          \begin{itemize}
              \item Công thức lực hấp dẫn với Softening
              \item Tính tổng lực từ tất cả body khác
          \end{itemize}

    \item \textbf{Galaxy Initialization:}
          \begin{itemize}
              \item Tạo $N$ body ngẫu nhiên theo hình cầu hoặc đĩa
              \item Vận tốc ban đầu để tạo chuyển động xoay
          \end{itemize}

    \item \textbf{Render bodies} như các điểm sáng
\end{enumerate}

\subsection{Code: Body Struct}
\begin{lstlisting}[language=C++, caption=Body.hpp]
#pragma once
#include "Vec3.hpp"
#include "raylib.h"

struct Body {
    Vec3 pos;      // Vi tri
    Vec3 vel;      // Van toc
    Vec3 acc;      // Gia toc (tinh moi frame)
    double mass;   // Khoi luong
    Color color;   // Mau hien thi
    
    // Constructor
    Body(Vec3 p = Vec3(), Vec3 v = Vec3(), double m = 1.0)
        : pos(p), vel(v), acc(Vec3()), mass(m), color(WHITE) {}
    
    // Cap nhat vi tri bang Euler Integration
    void update(double dt) {
        vel = vel + acc * dt;   // v = v + a*dt
        pos = pos + vel * dt;   // x = x + v*dt
        acc = Vec3();           // Reset gia toc cho frame sau
    }
    
    // Ve body len man hinh
    void draw() const {
        // Chuyen Vec3 sang Vector3 cua Raylib
        Vector3 rlPos = { (float)pos.x, (float)pos.y, (float)pos.z };
        DrawSphere(rlPos, 0.05f, color);  // Ve hinh cau nho
    }
};
\end{lstlisting}

\subsection{Code: Brute-Force Force Calculation}
\begin{lstlisting}[language=C++, caption=Physics.cpp]
#include <vector>
#include "Body.hpp"

// Hang so vat ly
const double G = 6.67430e-11;  // Hang so hap dan (SI units)
const double SOFTENING = 0.1;  // Tranh chia cho 0

// Tinh luc hap dan giua 2 body
Vec3 calculatePairForce(const Body& a, const Body& b) {
    Vec3 r = b.pos - a.pos;  // Vector tu a den b
    double distSq = r.x*r.x + r.y*r.y + r.z*r.z;
    
    // Them softening de tranh vo cuc khi dist -> 0
    double dist = sqrt(distSq + SOFTENING * SOFTENING);
    
    // F = G * m1 * m2 / r^2
    // a = F / m1 = G * m2 / r^2
    // Huong: r / |r| (normalized)
    double forceMagnitude = G * b.mass / (dist * dist * dist);
    
    return r * forceMagnitude;  // Vec3 acceleration
}

// BRUTE-FORCE: O(N^2)
void updateAllBodies_BruteForce(std::vector<Body>& bodies, double dt) {
    int N = bodies.size();
    
    // Tinh gia toc cho moi body
    for (int i = 0; i < N; i++) {
        Vec3 totalAcc;
        for (int j = 0; j < N; j++) {
            if (i != j) {
                totalAcc = totalAcc + calculatePairForce(bodies[i], bodies[j]);
            }
        }
        bodies[i].acc = totalAcc;
    }
    
    // Cap nhat vi tri
    for (int i = 0; i < N; i++) {
        bodies[i].update(dt);
    }
}
\end{lstlisting}

\subsection{Milestone: 500 Stars Moving}
\textbf{Kết quả mong đợi:} 500 điểm sáng di chuyển và bắt đầu tụ lại với nhau do lực hấp dẫn. FPS có thể thấp (20-30) - đây là bình thường cho Brute-force!

% -----------------------------------------------------------------------------
\chapter{Week 3: Octree Structure \& Visualization}

\section{Focus: Xây dựng cấu trúc Octree cơ bản}

\subsection{Tasks}
\begin{enumerate}
    \item \textbf{Implement \texttt{OctreeNode} class:}
          \begin{itemize}
              \item Constructor với center và size
              \item Mảng 8 con trỏ children
              \item Destructor đệ quy
          \end{itemize}

    \item \textbf{Implement \texttt{getOctantIndex()}:} Xác định body thuộc octant nào

    \item \textbf{Implement \texttt{subdivide()}:} Chia node thành 8 con

    \item \textbf{Visual Debug:} Vẽ wireframe của tất cả node
\end{enumerate}

\subsection{Code: OctreeNode Class}
\begin{lstlisting}[language=C++, caption=OctreeNode.hpp]
#pragma once
#include "Vec3.hpp"
#include "Body.hpp"
#include <array>

class OctreeNode {
public:
    // ==================== MEMBER VARIABLES ====================
    
    Vec3 center;           // Tam cua hinh lap phuong
    double halfSize;       // Nua canh (de tinh bounds)
    
    // === Du lieu vat ly (dung cho Barnes-Hut) ===
    double totalMass;      // Tong khoi luong cua node va cac con
    Vec3 centerOfMass;     // Trong tam khoi luong
    
    // === Cau truc cay ===
    Body* body;            // Chi dung khi la External Node (la)
    std::array<OctreeNode*, 8> children;  // 8 con tro den node con
    
    bool isExternal;       // true = la (khong co con)
    
    // ==================== CONSTRUCTOR/DESTRUCTOR ====================
    
    OctreeNode(Vec3 c, double size) 
        : center(c), halfSize(size / 2.0),
          totalMass(0.0), centerOfMass(Vec3()),
          body(nullptr), isExternal(true) 
    {
        // Khoi tao tat ca con tro children = nullptr
        for (int i = 0; i < 8; i++) {
            children[i] = nullptr;
        }
    }
    
    // Destructor DE QUY - xoa tat ca node con
    ~OctreeNode() {
        for (int i = 0; i < 8; i++) {
            if (children[i] != nullptr) {
                delete children[i];  // Goi destructor cua con
                children[i] = nullptr;
            }
        }
    }
    
    // ==================== METHODS ====================
    
    // Xac dinh octant index (0-7) cho mot diem
    int getOctantIndex(const Vec3& point) const {
        int index = 0;
        if (point.x >= center.x) index |= 1;  // Bit 0
        if (point.y >= center.y) index |= 2;  // Bit 1
        if (point.z >= center.z) index |= 4;  // Bit 2
        return index;
    }
    
    // Tinh tam cua octant thu i
    Vec3 getOctantCenter(int i) const {
        double offset = halfSize / 2.0;
        return Vec3(
            center.x + ((i & 1) ? offset : -offset),
            center.y + ((i & 2) ? offset : -offset),
            center.z + ((i & 4) ? offset : -offset)
        );
    }
    
    // Chia node thanh 8 con
    void subdivide() {
        double childSize = halfSize;  // Moi con co kich thuoc = nua cha
        for (int i = 0; i < 8; i++) {
            Vec3 childCenter = getOctantCenter(i);
            children[i] = new OctreeNode(childCenter, childSize);
        }
        isExternal = false;  // Khong con la la nua
    }
    
    // INSERT - Se implement o Week 4
    void insert(Body* newBody);
    
    // COMPUTE MASS - Se implement o Week 4  
    void computeMassDistribution();
    
    // CALCULATE FORCE - Se implement o Week 5
    Vec3 calculateForce(const Body* target, double theta, double G, double softening);
    
    // Ve wireframe de debug
    void drawWireframe(Color color) const {
        float s = (float)halfSize;
        Vector3 c = { (float)center.x, (float)center.y, (float)center.z };
        DrawCubeWires(c, s*2, s*2, s*2, color);
        
        // Ve de quy cac con
        if (!isExternal) {
            for (int i = 0; i < 8; i++) {
                if (children[i] != nullptr) {
                    children[i]->drawWireframe(color);
                }
            }
        }
    }
};
\end{lstlisting}

\subsection{Milestone: Octree Wireframe Visible}
\textbf{Kết quả mong đợi:} Các hình lập phương wireframe hiển thị, thể hiện cấu trúc phân cấp của Octree. Node có body sẽ được chia nhỏ hơn.

% -----------------------------------------------------------------------------
\chapter{Week 4: Octree Insert \& Mass Computation}

\section{Focus: Hoàn thiện Octree với Insert và ComputeMass}

\subsection{Tasks}
\begin{enumerate}
    \item \textbf{Implement \texttt{insert(Body*)}:}
          \begin{itemize}
              \item Xử lý 3 trường hợp: Node rỗng, Node có body, Node có con
              \item Logic đệ quy chia nhỏ khi cần
          \end{itemize}

    \item \textbf{Implement \texttt{computeMassDistribution()}:}
          \begin{itemize}
              \item Duyệt Post-order (con trước, cha sau)
              \item Tính totalMass và centerOfMass
          \end{itemize}

    \item \textbf{Debug \& Verify:}
          \begin{itemize}
              \item In ra \texttt{root->totalMass}
              \item Phải bằng tổng khối lượng tất cả body!
          \end{itemize}
\end{enumerate}

\subsection{Code: Insert Algorithm (Core of Octree)}
\begin{lstlisting}[language=C++, caption=OctreeNode::insert()]
void OctreeNode::insert(Body* newBody) {
    // ========== CASE 1: External node va rong ==========
    // Chi can gan body vao
    if (isExternal && body == nullptr) {
        body = newBody;
        return;
    }
    
    // ========== CASE 2: External node DA CO body ==========
    // Phai chia thanh 8 con, roi chen ca 2 body vao
    if (isExternal && body != nullptr) {
        // Buoc 1: Chia node hien tai
        subdivide();
        
        // Buoc 2: Chen body CU vao octant tuong ung
        Body* oldBody = body;
        body = nullptr;  // Node nay khong con la la nua
        
        int oldIndex = getOctantIndex(oldBody->pos);
        children[oldIndex]->insert(oldBody);  // DE QUY!
        
        // Buoc 3: Chen body MOI vao octant tuong ung
        int newIndex = getOctantIndex(newBody->pos);
        children[newIndex]->insert(newBody);  // DE QUY!
        
        return;
    }
    
    // ========== CASE 3: Internal node (da co con) ==========
    // Chi can tim octant dung va chen de quy
    int index = getOctantIndex(newBody->pos);
    
    // Tao node con neu chua ton tai
    if (children[index] == nullptr) {
        Vec3 childCenter = getOctantCenter(index);
        children[index] = new OctreeNode(childCenter, halfSize);
    }
    
    children[index]->insert(newBody);  // DE QUY!
}
\end{lstlisting}

\subsection{Code: Compute Mass Distribution}
\begin{lstlisting}[language=C++, caption=OctreeNode::computeMassDistribution()]
void OctreeNode::computeMassDistribution() {
    // ========== BASE CASE 1: Node rong ==========
    if (isExternal && body == nullptr) {
        totalMass = 0.0;
        centerOfMass = Vec3();
        return;
    }
    
    // ========== BASE CASE 2: La co body ==========
    if (isExternal && body != nullptr) {
        totalMass = body->mass;
        centerOfMass = body->pos;
        return;
    }
    
    // ========== RECURSIVE CASE: Node trong ==========
    // POST-ORDER: Tinh con truoc, cha sau
    
    // Buoc 1: Goi de quy cho tat ca con
    for (int i = 0; i < 8; i++) {
        if (children[i] != nullptr) {
            children[i]->computeMassDistribution();
        }
    }
    
    // Buoc 2: Tong hop tu cac con
    totalMass = 0.0;
    Vec3 weightedSum = Vec3();
    
    for (int i = 0; i < 8; i++) {
        if (children[i] != nullptr && children[i]->totalMass > 0) {
            double m = children[i]->totalMass;
            Vec3 com = children[i]->centerOfMass;
            
            weightedSum = weightedSum + com * m;
            totalMass += m;
        }
    }
    
    // Buoc 3: Tinh trong tam
    if (totalMass > 0) {
        centerOfMass = weightedSum / totalMass;
    }
}
\end{lstlisting}

\subsection{Milestone: Debug Verification}
\begin{lstlisting}[language=C++, caption=Verification Code]
// Trong main loop, sau khi build tree:
double totalBodyMass = 0.0;
for (const auto& b : bodies) {
    totalBodyMass += b.mass;
}

root->computeMassDistribution();

std::cout << "Sum of body masses: " << totalBodyMass << std::endl;
std::cout << "Root totalMass: " << root->totalMass << std::endl;
std::cout << "MATCH: " << (abs(totalBodyMass - root->totalMass) < 0.001 ? "YES" : "NO") << std::endl;
\end{lstlisting}

\textbf{Kết quả mong đợi:} Console in ra "MATCH: YES". Nếu không, có bug trong insert hoặc computeMass!

% -----------------------------------------------------------------------------
\chapter{Week 5: Barnes-Hut Force Calculation}

\section{Focus: Thuật toán Barnes-Hut hoàn chỉnh}

\subsection{Tasks}
\begin{enumerate}
    \item \textbf{Implement \texttt{calculateForce()}:}
          \begin{itemize}
              \item Kiểm tra Multipole Acceptance Criterion ($s/d < \theta$)
              \item Nếu đủ xa: dùng centerOfMass
              \item Nếu quá gần: đệ quy vào con
          \end{itemize}

    \item \textbf{Thay thế Brute-force bằng Barnes-Hut} trong main loop

    \item \textbf{Benchmark:} So sánh FPS giữa 2 phương pháp
\end{enumerate}

\subsection{Code: Barnes-Hut Force Calculation}
\begin{lstlisting}[language=C++, caption=OctreeNode::calculateForce()]
Vec3 OctreeNode::calculateForce(const Body* target, double theta, 
                                 double G, double softening) {
    // ========== CASE 1: Node rong ==========
    if (totalMass == 0.0) {
        return Vec3();  // Khong co luc
    }
    
    // ========== CASE 2: La voi 1 body ==========
    if (isExternal && body != nullptr) {
        // Khong tinh luc len chinh no
        if (body == target) {
            return Vec3();
        }
        
        // Tinh luc truc tiep
        Vec3 r = body->pos - target->pos;
        double distSq = r.x*r.x + r.y*r.y + r.z*r.z;
        double dist = sqrt(distSq + softening * softening);
        
        // a = G * m / r^2 * direction
        double magnitude = G * body->mass / (dist * dist * dist);
        return r * magnitude;
    }
    
    // ========== CASE 3: Node trong - BARNES-HUT LOGIC ==========
    Vec3 r = centerOfMass - target->pos;
    double distSq = r.x*r.x + r.y*r.y + r.z*r.z;
    double dist = sqrt(distSq);
    
    // Kich thuoc node
    double s = halfSize * 2.0;
    
    // *** MULTIPOLE ACCEPTANCE CRITERION ***
    // Neu s/d < theta, cum nay "du xa" de xap xi
    if (dist > 0 && (s / dist) < theta) {
        // Dung centerOfMass va totalMass de tinh
        double distSoftened = sqrt(distSq + softening * softening);
        double magnitude = G * totalMass / (distSoftened * distSoftened * distSoftened);
        return r * magnitude;
    }
    
    // Neu khong du xa, phai di sau vao cac con
    Vec3 totalForce;
    for (int i = 0; i < 8; i++) {
        if (children[i] != nullptr) {
            totalForce = totalForce + children[i]->calculateForce(
                target, theta, G, softening
            );  // DE QUY!
        }
    }
    
    return totalForce;
}
\end{lstlisting}

\subsection{Code: Main Loop with Barnes-Hut}
\begin{lstlisting}[language=C++, caption=Main Loop]
// Constants
const double THETA = 0.5;      // Accuracy parameter
const double G = 1.0;          // Simplified gravity constant
const double SOFTENING = 0.1;
const double DT = 0.01;        // Time step
const double UNIVERSE_SIZE = 100.0;

void simulationStep(std::vector<Body>& bodies) {
    // ====== STEP 1: Rebuild Octree ======
    // (Tree phai rebuild moi frame vi bodies di chuyen)
    
    Vec3 center(0, 0, 0);
    OctreeNode* root = new OctreeNode(center, UNIVERSE_SIZE);
    
    for (auto& body : bodies) {
        root->insert(&body);
    }
    
    // ====== STEP 2: Compute Mass Distribution ======
    root->computeMassDistribution();
    
    // ====== STEP 3: Calculate Forces using Barnes-Hut ======
    for (auto& body : bodies) {
        body.acc = root->calculateForce(&body, THETA, G, SOFTENING);
    }
    
    // ====== STEP 4: Update Positions ======
    for (auto& body : bodies) {
        body.update(DT);
    }
    
    // ====== STEP 5: Clean up ======
    delete root;  // Destructor se xoa toan bo cay
}
\end{lstlisting}

\subsection{Milestone: 5,000 Stars Real-time}
\textbf{Kết quả mong đợi:} FPS tăng đáng kể! Với $N=5,000$:
\begin{itemize}
    \item Brute-force: $\sim$5-10 FPS
    \item Barnes-Hut: $\sim$30-60 FPS
\end{itemize}

% -----------------------------------------------------------------------------
\chapter{Week 6: Optimization \& Boundary Handling}

\section{Focus: Tối ưu hóa và xử lý biên}

\subsection{Tasks}
\begin{enumerate}
    \item \textbf{OpenMP Parallelization:}
          \begin{itemize}
              \item Thêm \texttt{\#pragma omp parallel for} vào vòng tính lực
              \item Compile với flag \texttt{-fopenmp}
          \end{itemize}

    \item \textbf{Boundary Handling:}
          \begin{itemize}
              \item Xử lý body bay ra ngoài universe bounds
              \item Options: Bỏ qua, teleport, hoặc expand bounds
          \end{itemize}

    \item \textbf{Memory Optimization:}
          \begin{itemize}
              \item Reuse memory thay vì new/delete mỗi frame
              \item Object pooling cho OctreeNode
          \end{itemize}
\end{enumerate}

\subsection{Code: OpenMP Parallelization}
\begin{lstlisting}[language=C++, caption=Parallel Force Calculation]
#include <omp.h>

void simulationStep(std::vector<Body>& bodies) {
    // ... Build tree ...
    
    // *** PARALLEL FORCE CALCULATION ***
    // Chi can them 1 dong nay!
    #pragma omp parallel for
    for (size_t i = 0; i < bodies.size(); i++) {
        bodies[i].acc = root->calculateForce(&bodies[i], THETA, G, SOFTENING);
    }
    
    // Update cung co the parallel
    #pragma omp parallel for
    for (size_t i = 0; i < bodies.size(); i++) {
        bodies[i].update(DT);
    }
    
    delete root;
}
\end{lstlisting}

\subsection{Milestone: 10,000 Stars Stable > 30 FPS}
\textbf{Compile command:}
\begin{verbatim}
g++ -O3 -fopenmp main.cpp -o simulation -lraylib
\end{verbatim}

% -----------------------------------------------------------------------------
\chapter{Week 7: Visual Effects \& Polish}

\section{Focus: Đồ họa đẹp và UX}

\subsection{Tasks}
\begin{enumerate}
    \item \textbf{Mass-based Coloring:} Sao nhỏ = đỏ, sao lớn = xanh

    \item \textbf{Smooth Camera:}
          \begin{itemize}
              \item Orbital camera với zoom
              \item Follow camera theo center of mass
          \end{itemize}

    \item \textbf{UI Overlay:}
          \begin{itemize}
              \item Hiển thị FPS, số hạt, theta
              \item Controls help text
          \end{itemize}

    \item \textbf{Optional - Bloom Effect:} Post-processing cho sao phát sáng
\end{enumerate}

\subsection{Code: Mass to Color Mapping}
\begin{lstlisting}[language=C++, caption=Star Color based on Mass]
// Anh xa khoi luong sang mau sac (Quang pho sao)
// Do lun (Red Dwarf) -> Vang (Sun) -> Xanh khong lo (Blue Giant)
Color massToColor(double mass, double minMass, double maxMass) {
    // Normalize mass to [0, 1]
    double t = (mass - minMass) / (maxMass - minMass);
    t = fmax(0.0, fmin(1.0, t));  // Clamp
    
    unsigned char r, g, b;
    
    if (t < 0.25) {
        // Do dam -> Do nhat (Red Dwarf)
        double local_t = t / 0.25;
        r = 139 + (unsigned char)(116 * local_t);  // 139 -> 255
        g = 0 + (unsigned char)(69 * local_t);     // 0 -> 69
        b = 0;
    } 
    else if (t < 0.5) {
        // Do nhat -> Vang (Orange to Yellow)
        double local_t = (t - 0.25) / 0.25;
        r = 255;
        g = 69 + (unsigned char)(186 * local_t);   // 69 -> 255
        b = 0 + (unsigned char)(100 * local_t);    // 0 -> 100
    }
    else if (t < 0.75) {
        // Vang -> Trang (Yellow to White)
        double local_t = (t - 0.5) / 0.25;
        r = 255;
        g = 255;
        b = 100 + (unsigned char)(155 * local_t);  // 100 -> 255
    }
    else {
        // Trang -> Xanh (White to Blue Giant)
        double local_t = (t - 0.75) / 0.25;
        r = 255 - (unsigned char)(100 * local_t);  // 255 -> 155
        g = 255 - (unsigned char)(100 * local_t);  // 255 -> 155
        b = 255;
    }
    
    return (Color){ r, g, b, 255 };
}
\end{lstlisting}

\subsection{Milestone: Beautiful Galaxy Visualization}
Kết quả: Một thiên hà với sao nhiều màu sắc, camera mượt mà, và UI thông tin.

% -----------------------------------------------------------------------------
\chapter{Week 8: Documentation \& Demo}

\section{Focus: Hoàn thiện báo cáo và Demo}

\subsection{Tasks}
\begin{enumerate}
    \item \textbf{Báo cáo kỹ thuật:}
          \begin{itemize}
              \item Giải thích thuật toán với hình minh họa
              \item Biểu đồ so sánh performance
              \item Source code có comment đầy đủ
          \end{itemize}

    \item \textbf{Video Demo:}
          \begin{itemize}
              \item 3-5 phút showcase
              \item Thể hiện: Galaxy formation, real-time performance, code walkthrough
          \end{itemize}

    \item \textbf{Presentation Slides:}
          \begin{itemize}
              \item 15 slides max
              \item Focus: Problem → Solution → Demo → Lessons Learned
          \end{itemize}

    \item \textbf{Code Cleanup:}
          \begin{itemize}
              \item Xóa debug code
              \item Thêm README.md với build instructions
          \end{itemize}
\end{enumerate}

\subsection{Deliverables}
\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Item} & \textbf{Format}      \\
        \hline
        Source Code   & GitHub Repository    \\
        Báo cáo       & PDF (20-30 trang)    \\
        Video Demo    & MP4 (3-5 phút)       \\
        Slides        & PDF/PPTX (15 slides) \\
        \hline
    \end{tabular}
\end{table}

% =============================================================================
% PART IV: COMPLETE ARCHITECTURE & CODE SKELETON
% =============================================================================
\part{Kiến trúc Hệ thống \& Code Hoàn chỉnh}

\chapter{Project Structure}

\section{Directory Layout}
\begin{verbatim}
n-body-simulation/
|-- include/
|   |-- Vec3.hpp          # 3D Vector math
|   |-- Body.hpp          # Celestial body struct
|   |-- OctreeNode.hpp    # Octree data structure
|   |-- Physics.hpp       # Force calculations
|   |-- Galaxy.hpp        # Galaxy initialization
|   |-- Renderer.hpp      # Raylib rendering helpers
|
|-- src/
|   |-- main.cpp          # Entry point & main loop
|   |-- Vec3.cpp
|   |-- Body.cpp
|   |-- OctreeNode.cpp
|   |-- Physics.cpp
|   |-- Galaxy.cpp
|   |-- Renderer.cpp
|
|-- assets/               # (Optional) textures, fonts
|-- build/                # Compiled output
|-- CMakeLists.txt        # Build configuration
|-- README.md
\end{verbatim}

\chapter{Complete Code Implementation}

\section{Vec3.hpp - 3D Vector Mathematics}
\begin{lstlisting}[language=C++, caption=include/Vec3.hpp]
#pragma once
#include <cmath>

/**
 * @brief 3D Vector class for physics calculations
 * 
 * Tai sao dung struct thay vi class?
 * -> Vec3 la "Plain Old Data" (POD), khong can encapsulation
 * -> Performance tot hon khi copy
 */
struct Vec3 {
    double x, y, z;
    
    // ==================== CONSTRUCTORS ====================
    
    // Default constructor - khoi tao (0, 0, 0)
    Vec3() : x(0.0), y(0.0), z(0.0) {}
    
    // Parameterized constructor
    Vec3(double x_, double y_, double z_) : x(x_), y(y_), z(z_) {}
    
    // ==================== OPERATOR OVERLOADING ====================
    // Cho phep viet code toan hoc tu nhien: v1 + v2, v * 2.0, etc.
    
    // Vector + Vector
    Vec3 operator+(const Vec3& other) const {
        return Vec3(x + other.x, y + other.y, z + other.z);
    }
    
    // Vector - Vector
    Vec3 operator-(const Vec3& other) const {
        return Vec3(x - other.x, y - other.y, z - other.z);
    }
    
    // Vector * Scalar
    Vec3 operator*(double scalar) const {
        return Vec3(x * scalar, y * scalar, z * scalar);
    }
    
    // Vector / Scalar
    Vec3 operator/(double scalar) const {
        // Chu y: Khong check divide by zero o day de giu performance
        return Vec3(x / scalar, y / scalar, z / scalar);
    }
    
    // Compound assignment operators
    Vec3& operator+=(const Vec3& other) {
        x += other.x; y += other.y; z += other.z;
        return *this;
    }
    
    Vec3& operator-=(const Vec3& other) {
        x -= other.x; y -= other.y; z -= other.z;
        return *this;
    }
    
    Vec3& operator*=(double scalar) {
        x *= scalar; y *= scalar; z *= scalar;
        return *this;
    }
    
    // ==================== UTILITY METHODS ====================
    
    // Do dai binh phuong (tranh sqrt khi khong can)
    double magnitudeSq() const {
        return x*x + y*y + z*z;
    }
    
    // Do dai vector
    double magnitude() const {
        return std::sqrt(magnitudeSq());
    }
    
    // Khoang cach binh phuong den vector khac
    double distanceSq(const Vec3& other) const {
        double dx = x - other.x;
        double dy = y - other.y;
        double dz = z - other.z;
        return dx*dx + dy*dy + dz*dz;
    }
    
    // Khoang cach den vector khac
    double distance(const Vec3& other) const {
        return std::sqrt(distanceSq(other));
    }
    
    // Normalize (do dai = 1)
    Vec3 normalized() const {
        double mag = magnitude();
        if (mag > 0) {
            return *this / mag;
        }
        return Vec3();  // Tra ve (0,0,0) neu vector = 0
    }
    
    // Dot product (tich vo huong)
    double dot(const Vec3& other) const {
        return x*other.x + y*other.y + z*other.z;
    }
    
    // Cross product (tich co huong)
    Vec3 cross(const Vec3& other) const {
        return Vec3(
            y*other.z - z*other.y,
            z*other.x - x*other.z,
            x*other.y - y*other.x
        );
    }
};

// Scalar * Vector (cho phep viet: 2.0 * vec)
inline Vec3 operator*(double scalar, const Vec3& vec) {
    return vec * scalar;
}
\end{lstlisting}

\section{Body.hpp - Celestial Body Structure}
\begin{lstlisting}[language=C++, caption=include/Body.hpp]
#pragma once
#include "Vec3.hpp"
#include "raylib.h"

/**
 * @brief Represents a celestial body (star, planet, particle)
 * 
 * Moi Body co:
 * - Position (vi tri trong khong gian 3D)
 * - Velocity (van toc - huong va toc do di chuyen)
 * - Acceleration (gia toc - duoc tinh moi frame tu luc hap dan)
 * - Mass (khoi luong - quyet dinh luc hap dan)
 * - Color (mau sac hien thi)
 */
struct Body {
    // ==================== PHYSICS PROPERTIES ====================
    Vec3 pos;      // Position (meters in simulation space)
    Vec3 vel;      // Velocity (meters/second)
    Vec3 acc;      // Acceleration (meters/second^2) - reset moi frame
    double mass;   // Mass (kilograms)
    
    // ==================== VISUAL PROPERTIES ====================
    Color color;   // Raylib Color for rendering
    float radius;  // Visual radius for drawing
    
    // ==================== CONSTRUCTORS ====================
    
    Body() 
        : pos(Vec3()), vel(Vec3()), acc(Vec3()), 
          mass(1.0), color(WHITE), radius(0.1f) {}
    
    Body(Vec3 position, Vec3 velocity, double m)
        : pos(position), vel(velocity), acc(Vec3()),
          mass(m), color(WHITE), radius(0.1f) {}
    
    // ==================== PHYSICS METHODS ====================
    
    /**
     * @brief Update position using Semi-implicit Euler integration
     * @param dt Time step (seconds)
     * 
     * Semi-implicit Euler (aka Symplectic Euler):
     * 1. v_new = v + a * dt
     * 2. x_new = x + v_new * dt  (dung v MOI, khong phai v cu)
     * 
     * Tai sao khong dung Euler thuong?
     * -> Euler thuong: x_new = x + v * dt (dung v cu)
     * -> Gay ra "energy drift" - nang luong tang theo thoi gian
     * -> Semi-implicit Euler bao toan nang luong tot hon
     */
    void update(double dt) {
        // Step 1: Update velocity with current acceleration
        vel = vel + acc * dt;
        
        // Step 2: Update position with NEW velocity
        pos = pos + vel * dt;
        
        // Step 3: Reset acceleration for next frame
        // (Se duoc tinh lai trong calculateForce)
        acc = Vec3();
    }
    
    /**
     * @brief Verlet Integration (more stable for long simulations)
     * @param dt Time step
     * 
     * Velocity Verlet algorithm:
     * x_new = x + v*dt + 0.5*a*dt^2
     * v_new = v + 0.5*(a_old + a_new)*dt
     * 
     * Note: Can tinh a_new truoc khi update velocity
     * Phuc tap hon nhung chinh xac hon Euler
     */
    void updateVerlet(double dt, const Vec3& newAcc) {
        // Update position
        pos = pos + vel * dt + acc * (0.5 * dt * dt);
        
        // Update velocity using average of old and new acceleration
        vel = vel + (acc + newAcc) * (0.5 * dt);
        
        // Store new acceleration
        acc = newAcc;
    }
    
    // ==================== RENDERING METHODS ====================
    
    /**
     * @brief Draw the body as a sphere in 3D space
     */
    void draw() const {
        // Convert Vec3 to Raylib's Vector3
        Vector3 rlPos = { 
            static_cast<float>(pos.x), 
            static_cast<float>(pos.y), 
            static_cast<float>(pos.z) 
        };
        
        // Draw solid sphere
        DrawSphere(rlPos, radius, color);
    }
    
    /**
     * @brief Draw as a point (faster for many bodies)
     */
    void drawPoint() const {
        Vector3 rlPos = { 
            static_cast<float>(pos.x), 
            static_cast<float>(pos.y), 
            static_cast<float>(pos.z) 
        };
        DrawPoint3D(rlPos, color);
    }
};
\end{lstlisting}

\section{OctreeNode.hpp - Complete Octree Implementation}
\begin{lstlisting}[language=C++, caption=include/OctreeNode.hpp]
#pragma once
#include "Vec3.hpp"
#include "Body.hpp"
#include <array>
#include <cmath>

/**
 * @brief Octree Node for Barnes-Hut algorithm
 * 
 * Octree la cau truc cay phan hoach khong gian 3D.
 * Moi node dai dien cho mot hinh lap phuong (cube) trong khong gian.
 * 
 * Co 2 loai node:
 * 1. External (Leaf): Khong co con, chua toi da 1 body
 * 2. Internal: Co it nhat 1 con, luu totalMass va centerOfMass
 */
class OctreeNode {
public:
    // ==================== SPATIAL PROPERTIES ====================
    Vec3 center;       // Tam cua hinh lap phuong
    double halfSize;   // Nua canh (bounds: center +/- halfSize)
    
    // ==================== PHYSICS PROPERTIES (for Barnes-Hut) ====================
    double totalMass;     // Tong khoi luong cua node va cac con
    Vec3 centerOfMass;    // Trong tam khoi luong (weighted average)
    
    // ==================== TREE STRUCTURE ====================
    Body* body;                         // Con tro den body (chi khi la External)
    std::array<OctreeNode*, 8> children;  // 8 con tro den node con
    bool isExternal;                    // true = leaf node
    
    // ==================== CONSTRUCTOR ====================
    
    /**
     * @brief Construct a new Octree Node
     * @param c Center position of the cube
     * @param size Full size of the cube edge
     */
    OctreeNode(Vec3 c, double size) 
        : center(c), 
          halfSize(size / 2.0),
          totalMass(0.0),
          centerOfMass(Vec3()),
          body(nullptr),
          isExternal(true)
    {
        // Khoi tao tat ca children = nullptr
        // Su dung std::array::fill() cho clean code
        children.fill(nullptr);
    }
    
    // ==================== DESTRUCTOR ====================
    
    /**
     * @brief Recursive destructor - delete entire subtree
     * 
     * QUAN TRONG: Day la vi du cua DE QUY trong destructor.
     * Khi delete root, no se tu dong delete tat ca node con.
     */
    ~OctreeNode() {
        for (int i = 0; i < 8; i++) {
            if (children[i] != nullptr) {
                delete children[i];  // Goi destructor cua con (DE QUY!)
                children[i] = nullptr;
            }
        }
    }
    
    // ==================== HELPER METHODS ====================
    
    /**
     * @brief Determine which octant a point belongs to
     * @param point The 3D position to check
     * @return Index 0-7 representing the octant
     * 
     * Octant indexing using bit flags:
     * Bit 0 (value 1): X >= center.x
     * Bit 1 (value 2): Y >= center.y
     * Bit 2 (value 4): Z >= center.z
     * 
     * Example: point at (5, -2, 3) with center (0, 0, 0)
     * - X >= 0: true  -> bit 0 = 1
     * - Y >= 0: false -> bit 1 = 0
     * - Z >= 0: true  -> bit 2 = 1
     * - Result: 0b101 = 5
     */
    int getOctantIndex(const Vec3& point) const {
        int index = 0;
        if (point.x >= center.x) index |= 1;
        if (point.y >= center.y) index |= 2;
        if (point.z >= center.z) index |= 4;
        return index;
    }
    
    /**
     * @brief Calculate the center position of a child octant
     * @param i Octant index (0-7)
     * @return Center position of the child cube
     */
    Vec3 getOctantCenter(int i) const {
        double offset = halfSize / 2.0;
        return Vec3(
            center.x + ((i & 1) ? offset : -offset),
            center.y + ((i & 2) ? offset : -offset),
            center.z + ((i & 4) ? offset : -offset)
        );
    }
    
    /**
     * @brief Check if a point is within this node's bounds
     */
    bool contains(const Vec3& point) const {
        return (point.x >= center.x - halfSize && point.x < center.x + halfSize) &&
               (point.y >= center.y - halfSize && point.y < center.y + halfSize) &&
               (point.z >= center.z - halfSize && point.z < center.z + halfSize);
    }
    
    // ==================== CORE ALGORITHMS ====================
    
    /**
     * @brief Subdivide this node into 8 children
     * 
     * Duoc goi khi can chen body thu 2 vao External node.
     */
    void subdivide() {
        double childSize = halfSize;  // Moi con co kich thuoc = nua cha
        
        for (int i = 0; i < 8; i++) {
            Vec3 childCenter = getOctantCenter(i);
            children[i] = new OctreeNode(childCenter, childSize);
        }
        
        isExternal = false;  // Node nay tro thanh Internal
    }
    
    /**
     * @brief Insert a body into the octree
     * @param newBody Pointer to the body to insert
     * 
     * THUAT TOAN INSERT (De quy):
     * 
     * Case 1: External node, rong
     *   -> Gan body vao, xong
     * 
     * Case 2: External node, da co body
     *   -> Chia thanh 8 con (subdivide)
     *   -> Chen body cu vao octant tuong ung
     *   -> Chen body moi vao octant tuong ung
     * 
     * Case 3: Internal node (da co con)
     *   -> Tim octant chua body moi
     *   -> Tao node con neu chua ton tai
     *   -> Goi insert de quy vao node con
     */
    void insert(Body* newBody) {
        // Kiem tra body co nam trong bounds khong
        if (!contains(newBody->pos)) {
            // Body ngoai bounds - co the skip hoac expand tree
            return;
        }
        
        // CASE 1: External node va rong
        if (isExternal && body == nullptr) {
            body = newBody;
            return;
        }
        
        // CASE 2: External node DA CO body
        if (isExternal && body != nullptr) {
            // Luu body cu
            Body* existingBody = body;
            body = nullptr;
            
            // Chia node
            subdivide();
            
            // Chen lai body cu
            int existingIndex = getOctantIndex(existingBody->pos);
            children[existingIndex]->insert(existingBody);  // DE QUY
            
            // Chen body moi
            int newIndex = getOctantIndex(newBody->pos);
            children[newIndex]->insert(newBody);  // DE QUY
            
            return;
        }
        
        // CASE 3: Internal node
        int index = getOctantIndex(newBody->pos);
        
        // Tao node con neu chua co
        if (children[index] == nullptr) {
            Vec3 childCenter = getOctantCenter(index);
            children[index] = new OctreeNode(childCenter, halfSize);
        }
        
        children[index]->insert(newBody);  // DE QUY
    }
    
    /**
     * @brief Compute total mass and center of mass for Barnes-Hut
     * 
     * THUAT TOAN COMPUTE MASS (Post-order traversal):
     * 
     * 1. Neu la External rong: mass = 0
     * 2. Neu la External co body: mass = body.mass, COM = body.pos
     * 3. Neu la Internal:
     *    a. Goi de quy cho tat ca con (POST-ORDER!)
     *    b. Tong hop: totalMass = sum(child.totalMass)
     *    c. COM = sum(child.COM * child.mass) / totalMass
     */
    void computeMassDistribution() {
        // BASE CASE 1: External rong
        if (isExternal && body == nullptr) {
            totalMass = 0.0;
            centerOfMass = Vec3();
            return;
        }
        
        // BASE CASE 2: External co body
        if (isExternal && body != nullptr) {
            totalMass = body->mass;
            centerOfMass = body->pos;
            return;
        }
        
        // RECURSIVE CASE: Internal node
        // Buoc 1: Tinh cho tat ca con truoc (POST-ORDER!)
        for (int i = 0; i < 8; i++) {
            if (children[i] != nullptr) {
                children[i]->computeMassDistribution();
            }
        }
        
        // Buoc 2: Tong hop tu cac con
        totalMass = 0.0;
        Vec3 weightedSum;
        
        for (int i = 0; i < 8; i++) {
            if (children[i] != nullptr && children[i]->totalMass > 0.0) {
                totalMass += children[i]->totalMass;
                weightedSum += children[i]->centerOfMass * children[i]->totalMass;
            }
        }
        
        // Buoc 3: Tinh Center of Mass
        if (totalMass > 0.0) {
            centerOfMass = weightedSum / totalMass;
        }
    }
    
    /**
     * @brief Calculate gravitational force on a target body using Barnes-Hut
     * @param target Body to calculate force on
     * @param theta Accuracy parameter (typically 0.5)
     * @param G Gravitational constant
     * @param softening Softening parameter to avoid singularity
     * @return Acceleration vector
     * 
     * THUAT TOAN BARNES-HUT:
     * 
     * 1. Neu node rong: return 0
     * 2. Neu la External co body (va khong phai chinh no):
     *    -> Tinh luc truc tiep
     * 3. Neu la Internal:
     *    a. Tinh ratio = s / d (kich thuoc / khoang cach)
     *    b. Neu ratio < theta: "Du xa", dung centerOfMass de tinh
     *    c. Neu ratio >= theta: "Qua gan", di sau vao cac con
     */
    Vec3 calculateForce(const Body* target, double theta, 
                        double G, double softening) const {
        // CASE 1: Node rong
        if (totalMass == 0.0) {
            return Vec3();
        }
        
        // CASE 2: External co body
        if (isExternal && body != nullptr) {
            // Khong tinh luc len chinh no
            if (body == target) {
                return Vec3();
            }
            
            // Tinh luc truc tiep
            Vec3 r = body->pos - target->pos;
            double distSq = r.magnitudeSq();
            double dist = std::sqrt(distSq + softening * softening);
            
            // F = G * m1 * m2 / r^2
            // a = F / m1 = G * m2 / r^2
            // Huong: r / |r| (normalized)
            // Ket hop: a = G * m * r / |r|^3
            double magnitude = G * body->mass / (dist * dist * dist);
            return r * magnitude;
        }
        
        // CASE 3: Internal node - BARNES-HUT DECISION
        Vec3 r = centerOfMass - target->pos;
        double distSq = r.magnitudeSq();
        double dist = std::sqrt(distSq);
        
        // Kich thuoc node (canh day du)
        double s = halfSize * 2.0;
        
        // *** MULTIPOLE ACCEPTANCE CRITERION ***
        // s/d < theta nghia la: "cum nay du xa de xap xi"
        if (dist > 0 && (s / dist) < theta) {
            // Du xa -> Coi nhu 1 khoi luong duy nhat tai centerOfMass
            double distSoftened = std::sqrt(distSq + softening * softening);
            double magnitude = G * totalMass / (distSoftened * distSoftened * distSoftened);
            return r * magnitude;
        }
        
        // Qua gan -> Phai di sau vao tung con
        Vec3 totalForce;
        for (int i = 0; i < 8; i++) {
            if (children[i] != nullptr) {
                totalForce += children[i]->calculateForce(target, theta, G, softening);
            }
        }
        
        return totalForce;
    }
    
    // ==================== DEBUG & VISUALIZATION ====================
    
    /**
     * @brief Draw wireframe representation of the octree
     */
    void drawWireframe(Color color = GREEN) const {
        // Convert to Raylib types
        Vector3 c = { 
            static_cast<float>(center.x), 
            static_cast<float>(center.y), 
            static_cast<float>(center.z) 
        };
        float size = static_cast<float>(halfSize * 2.0);
        
        // Draw this node's cube
        DrawCubeWires(c, size, size, size, color);
        
        // Recursively draw children
        if (!isExternal) {
            for (int i = 0; i < 8; i++) {
                if (children[i] != nullptr) {
                    children[i]->drawWireframe(color);
                }
            }
        }
    }
    
    /**
     * @brief Count total nodes in the tree (for debugging)
     */
    int countNodes() const {
        int count = 1;  // This node
        if (!isExternal) {
            for (int i = 0; i < 8; i++) {
                if (children[i] != nullptr) {
                    count += children[i]->countNodes();
                }
            }
        }
        return count;
    }
    
    /**
     * @brief Get maximum depth of the tree
     */
    int maxDepth() const {
        if (isExternal) return 1;
        
        int maxChildDepth = 0;
        for (int i = 0; i < 8; i++) {
            if (children[i] != nullptr) {
                maxChildDepth = std::max(maxChildDepth, children[i]->maxDepth());
            }
        }
        return 1 + maxChildDepth;
    }
};
\end{lstlisting}

\section{Galaxy.hpp - Galaxy Initialization}
\begin{lstlisting}[language=C++, caption=include/Galaxy.hpp]
#pragma once
#include "Body.hpp"
#include <vector>
#include <random>
#include <cmath>

/**
 * @brief Galaxy initialization utilities
 * 
 * Cung cap cac ham de tao galaxy ban dau voi:
 * - Phan bo khoi luong thuc te
 * - Van toc xoay de galaxy on dinh
 */

namespace Galaxy {

/**
 * @brief Create a disk-shaped galaxy
 * @param numBodies Number of stars
 * @param diskRadius Radius of the disk
 * @param diskHeight Thickness of the disk
 * @param centralMass Mass of central black hole (optional)
 * @return Vector of initialized bodies
 */
std::vector<Body> createDiskGalaxy(int numBodies, double diskRadius, 
                                    double diskHeight, double centralMass = 0.0) {
    std::vector<Body> bodies;
    bodies.reserve(numBodies);
    
    // Random number generator
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double> angleDist(0.0, 2.0 * M_PI);
    std::uniform_real_distribution<double> heightDist(-diskHeight/2, diskHeight/2);
    std::uniform_real_distribution<double> massDist(0.5, 2.0);  // Solar masses
    
    // Exponential radius distribution (more stars near center)
    std::exponential_distribution<double> radiusDist(3.0 / diskRadius);
    
    // Optional: Central massive object (black hole)
    if (centralMass > 0.0) {
        Body centralBody(Vec3(0, 0, 0), Vec3(0, 0, 0), centralMass);
        centralBody.color = YELLOW;
        centralBody.radius = 0.5f;
        bodies.push_back(centralBody);
    }
    
    // Create stars
    for (int i = 0; i < numBodies; i++) {
        // Position in disk
        double r = std::min(radiusDist(gen), diskRadius);
        double theta = angleDist(gen);
        double h = heightDist(gen);
        
        Vec3 pos(r * cos(theta), h, r * sin(theta));
        
        // Velocity: Orbital velocity for circular orbit
        // v = sqrt(G * M_enclosed / r)
        // Simplified: Assume enclosed mass proportional to r
        double orbitalSpeed = 0.0;
        if (r > 0.1) {
            // Empirical formula for realistic rotation curve
            double enclosedMass = centralMass + (double)i * 1.0 * (r / diskRadius);
            orbitalSpeed = sqrt(0.1 * enclosedMass / r);  // Simplified
        }
        
        // Perpendicular to radius (tangent direction for orbit)
        Vec3 vel(-orbitalSpeed * sin(theta), 0.0, orbitalSpeed * cos(theta));
        
        // Random mass
        double mass = massDist(gen);
        
        Body star(pos, vel, mass);
        bodies.push_back(star);
    }
    
    return bodies;
}

/**
 * @brief Create a spherical cluster
 * @param numBodies Number of stars
 * @param clusterRadius Radius of sphere
 * @return Vector of initialized bodies
 */
std::vector<Body> createSphereCluster(int numBodies, double clusterRadius) {
    std::vector<Body> bodies;
    bodies.reserve(numBodies);
    
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double> dist(-1.0, 1.0);
    std::uniform_real_distribution<double> massDist(0.5, 2.0);
    
    for (int i = 0; i < numBodies; i++) {
        // Random point in sphere using rejection sampling
        Vec3 pos;
        do {
            pos = Vec3(dist(gen), dist(gen), dist(gen));
        } while (pos.magnitudeSq() > 1.0);
        
        pos = pos * clusterRadius;
        
        // Small random velocity
        Vec3 vel(dist(gen) * 0.1, dist(gen) * 0.1, dist(gen) * 0.1);
        
        double mass = massDist(gen);
        
        bodies.push_back(Body(pos, vel, mass));
    }
    
    return bodies;
}

/**
 * @brief Create two colliding galaxies
 */
std::vector<Body> createCollidingGalaxies(int bodiesPerGalaxy, double separation) {
    // Galaxy 1 at origin
    auto galaxy1 = createDiskGalaxy(bodiesPerGalaxy, 20.0, 2.0, 100.0);
    
    // Galaxy 2 offset and moving toward galaxy 1
    auto galaxy2 = createDiskGalaxy(bodiesPerGalaxy, 20.0, 2.0, 100.0);
    
    // Offset galaxy 2
    for (auto& body : galaxy2) {
        body.pos.x += separation;
        body.vel.x -= 0.5;  // Moving toward galaxy 1
    }
    
    // Combine
    galaxy1.insert(galaxy1.end(), galaxy2.begin(), galaxy2.end());
    return galaxy1;
}

} // namespace Galaxy
\end{lstlisting}

\section{main.cpp - Complete Simulation Loop}
\begin{lstlisting}[language=C++, caption=src/main.cpp]
/**
 * @file main.cpp
 * @brief 3D N-Body Simulation using Barnes-Hut Algorithm
 * 
 * Main entry point for the simulation.
 * Handles:
 * - Raylib window initialization
 * - Main loop (Input -> Physics -> Render)
 * - Camera controls
 * - Performance monitoring
 */

#include "raylib.h"
#include "Vec3.hpp"
#include "Body.hpp"
#include "OctreeNode.hpp"
#include "Galaxy.hpp"

#include <vector>
#include <iostream>
#include <chrono>

// ==================== SIMULATION CONSTANTS ====================

namespace Config {
    // Window
    constexpr int SCREEN_WIDTH = 1280;
    constexpr int SCREEN_HEIGHT = 720;
    constexpr int TARGET_FPS = 60;
    
    // Simulation
    constexpr int NUM_BODIES = 10000;
    constexpr double UNIVERSE_SIZE = 200.0;  // Half-size of simulation space
    constexpr double G = 1.0;                 // Gravitational constant (scaled)
    constexpr double SOFTENING = 0.5;         // Softening parameter
    constexpr double DT = 0.016;              // Time step (~60 FPS)
    constexpr double THETA = 0.5;             // Barnes-Hut accuracy (0.5 is typical)
    
    // Visual
    constexpr bool DRAW_OCTREE = false;       // Toggle octree visualization
}

// ==================== COLOR MAPPING ====================

/**
 * @brief Map star mass to stellar color (Red Dwarf -> Blue Giant)
 */
Color massToColor(double mass, double minMass, double maxMass) {
    double t = (mass - minMass) / (maxMass - minMass);
    t = fmax(0.0, fmin(1.0, t));  // Clamp to [0, 1]
    
    unsigned char r, g, b;
    
    if (t < 0.33) {
        // Red -> Orange
        double lt = t / 0.33;
        r = 200;
        g = static_cast<unsigned char>(50 + 150 * lt);
        b = 50;
    } else if (t < 0.66) {
        // Orange -> White
        double lt = (t - 0.33) / 0.33;
        r = 255;
        g = static_cast<unsigned char>(200 + 55 * lt);
        b = static_cast<unsigned char>(50 + 205 * lt);
    } else {
        // White -> Blue
        double lt = (t - 0.66) / 0.34;
        r = static_cast<unsigned char>(255 - 100 * lt);
        g = static_cast<unsigned char>(255 - 100 * lt);
        b = 255;
    }
    
    return Color{r, g, b, 255};
}

/**
 * @brief Apply colors to all bodies based on mass
 */
void applyMassColors(std::vector<Body>& bodies) {
    if (bodies.empty()) return;
    
    // Find mass range
    double minMass = bodies[0].mass;
    double maxMass = bodies[0].mass;
    for (const auto& b : bodies) {
        minMass = fmin(minMass, b.mass);
        maxMass = fmax(maxMass, b.mass);
    }
    
    // Apply colors
    for (auto& b : bodies) {
        b.color = massToColor(b.mass, minMass, maxMass);
        b.radius = 0.05f + 0.1f * static_cast<float>((b.mass - minMass) / (maxMass - minMass));
    }
}

// ==================== MAIN FUNCTION ====================

int main() {
    // ========== INITIALIZATION ==========
    
    // Initialize Raylib window
    InitWindow(Config::SCREEN_WIDTH, Config::SCREEN_HEIGHT, 
               "N-Body Simulation - Barnes-Hut Algorithm");
    SetTargetFPS(Config::TARGET_FPS);
    
    // Initialize 3D camera
    Camera3D camera = { 0 };
    camera.position = Vector3{ 100.0f, 80.0f, 100.0f };
    camera.target = Vector3{ 0.0f, 0.0f, 0.0f };
    camera.up = Vector3{ 0.0f, 1.0f, 0.0f };
    camera.fovy = 60.0f;
    camera.projection = CAMERA_PERSPECTIVE;
    
    // Create galaxy
    std::cout << "Initializing " << Config::NUM_BODIES << " bodies..." << std::endl;
    std::vector<Body> bodies = Galaxy::createDiskGalaxy(
        Config::NUM_BODIES, 
        50.0,   // Disk radius
        5.0,    // Disk height
        1000.0  // Central mass
    );
    
    // Apply colors based on mass
    applyMassColors(bodies);
    
    std::cout << "Simulation ready! Bodies: " << bodies.size() << std::endl;
    
    // Performance metrics
    double physicsTime = 0.0;
    int frameCount = 0;
    
    // ========== MAIN LOOP ==========
    
    while (!WindowShouldClose()) {
        // ====== INPUT ======
        UpdateCamera(&camera, CAMERA_ORBITAL);
        
        // Keyboard controls
        if (IsKeyPressed(KEY_R)) {
            // Reset simulation
            bodies = Galaxy::createDiskGalaxy(Config::NUM_BODIES, 50.0, 5.0, 1000.0);
            applyMassColors(bodies);
        }
        
        if (IsKeyPressed(KEY_SPACE)) {
            // Toggle pause (not implemented - exercise for reader)
        }
        
        // ====== PHYSICS (Barnes-Hut) ======
        auto physicsStart = std::chrono::high_resolution_clock::now();
        
        // Step 1: Build Octree
        Vec3 center(0, 0, 0);
        OctreeNode* root = new OctreeNode(center, Config::UNIVERSE_SIZE * 2);
        
        for (auto& body : bodies) {
            root->insert(&body);
        }
        
        // Step 2: Compute mass distribution
        root->computeMassDistribution();
        
        // Step 3: Calculate forces using Barnes-Hut
        #ifdef _OPENMP
        #pragma omp parallel for
        #endif
        for (size_t i = 0; i < bodies.size(); i++) {
            bodies[i].acc = root->calculateForce(
                &bodies[i], 
                Config::THETA, 
                Config::G, 
                Config::SOFTENING
            );
        }
        
        // Step 4: Update positions
        for (auto& body : bodies) {
            body.update(Config::DT);
        }
        
        // Cleanup
        int treeNodes = root->countNodes();
        int treeDepth = root->maxDepth();
        delete root;
        root = nullptr;
        
        auto physicsEnd = std::chrono::high_resolution_clock::now();
        physicsTime = std::chrono::duration<double, std::milli>(physicsEnd - physicsStart).count();
        
        // ====== RENDERING ======
        BeginDrawing();
            ClearBackground(Color{5, 5, 15, 255});  // Deep space blue
            
            BeginMode3D(camera);
                // Draw all bodies
                for (const auto& body : bodies) {
                    body.draw();
                }
                
                // Optional: Draw octree wireframe
                if (Config::DRAW_OCTREE && root != nullptr) {
                    root->drawWireframe(Color{0, 100, 0, 100});
                }
                
                // Reference grid
                DrawGrid(20, 10.0f);
            EndMode3D();
            
            // UI Overlay
            DrawRectangle(10, 10, 300, 150, Color{0, 0, 0, 150});
            DrawText("N-Body Simulation (Barnes-Hut)", 20, 20, 20, WHITE);
            DrawText(TextFormat("Bodies: %d", (int)bodies.size()), 20, 50, 16, GREEN);
            DrawText(TextFormat("FPS: %d", GetFPS()), 20, 70, 16, GREEN);
            DrawText(TextFormat("Physics: %.2f ms", physicsTime), 20, 90, 16, YELLOW);
            DrawText(TextFormat("Tree Nodes: %d", treeNodes), 20, 110, 16, GRAY);
            DrawText(TextFormat("Tree Depth: %d", treeDepth), 20, 130, 16, GRAY);
            
            DrawText("Controls: Mouse to orbit, R to reset", 20, SCREEN_HEIGHT - 30, 16, GRAY);
        EndDrawing();
        
        frameCount++;
    }
    
    // ========== CLEANUP ==========
    CloseWindow();
    
    return 0;
}
\end{lstlisting}

% =============================================================================
% PART V: PHYSICS & VISUAL MATHEMATICS
% =============================================================================
\part{Vật lý và Toán học Đồ họa}

\chapter{Newton's Law of Gravitation}

\section{Công thức Lực Hấp dẫn}

Lực hút giữa hai vật thể $i$ và $j$ được mô tả bởi định luật Newton:

\begin{equation}
    \boxed{\vec{F}_{ij} = G \frac{m_i m_j}{r_{ij}^2} \hat{r}_{ij}}
\end{equation}

Trong đó:
\begin{itemize}
    \item $G = 6.674 \times 10^{-11} \text{ N}\cdot\text{m}^2/\text{kg}^2$ — Hằng số hấp dẫn
    \item $m_i, m_j$ — Khối lượng của hai vật thể
    \item $r_{ij} = |\vec{r}_j - \vec{r}_i|$ — Khoảng cách giữa hai vật thể
    \item $\hat{r}_{ij}$ — Vector đơn vị hướng từ $i$ đến $j$
\end{itemize}

\section{Từ Lực đến Gia tốc}

Theo định luật Newton thứ 2: $\vec{F} = m\vec{a}$

Do đó, gia tốc của vật thể $i$ do vật thể $j$ gây ra:

\begin{equation}
    \vec{a}_{ij} = \frac{\vec{F}_{ij}}{m_i} = G \frac{m_j}{r_{ij}^2} \hat{r}_{ij}
\end{equation}

\begin{importantbox}
    Trong code, ta tính gia tốc (không phải lực) vì:
    \begin{enumerate}
        \item Không cần nhân với khối lượng của target body
        \item Trực tiếp cộng vào velocity khi update
    \end{enumerate}
\end{importantbox}

\section{Softening Parameter ($\epsilon$)}

\subsection{Vấn đề: Division by Zero}
Khi hai vật thể quá gần nhau ($r \rightarrow 0$):
\begin{equation}
    \vec{a} = G \frac{m}{r^2} \rightarrow \infty
\end{equation}

Điều này gây ra:
\begin{itemize}
    \item Numerical overflow trong code
    \item Vận tốc tăng vọt phi thực tế
    \item Vật thể "bắn" ra khỏi simulation
\end{itemize}

\subsection{Giải pháp: Plummer Softening}
Thay $r$ bằng $\sqrt{r^2 + \epsilon^2}$:

\begin{equation}
    \boxed{\vec{a}_{ij} = G \frac{m_j}{(r_{ij}^2 + \epsilon^2)^{3/2}} \vec{r}_{ij}}
\end{equation}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=1.2]
        \draw[->] (0,0) -- (5,0) node[right] {$r$};
        \draw[->] (0,0) -- (0,4) node[above] {$a$};

        % Without softening (diverges)
        \draw[thick, red, domain=0.3:4.5, samples=100]
        plot (\x, {min(3.5, 1/(\x*\x))});

        % With softening
        \draw[thick, blue, domain=0.01:4.5, samples=100]
        plot (\x, {1/pow(\x*\x + 0.5*0.5, 1.5)});

        \node[red] at (1.5, 3.5) {Không softening};
        \node[blue] at (3, 1.5) {Có softening};
    \end{tikzpicture}
    \caption{So sánh gia tốc có và không có softening}
\end{figure}

\begin{tipbox}
    \textbf{Chọn giá trị $\epsilon$:}
    \begin{itemize}
        \item Quá nhỏ: Vẫn có numerical instability
        \item Quá lớn: Mất độ chính xác, các sao không tương tác đủ mạnh
        \item \textbf{Khuyến nghị:} $\epsilon \approx$ kích thước trung bình của vật thể, hoặc $\sim$1\% khoảng cách trung bình
    \end{itemize}
\end{tipbox}

\section{Implementation trong Code}

\begin{lstlisting}[language=C++, caption=Complete Force Calculation]
/**
 * @brief Calculate gravitational acceleration with softening
 * @param target The body receiving the force
 * @param source The body exerting the force
 * @param G Gravitational constant
 * @param epsilon Softening parameter
 * @return Acceleration vector
 */
Vec3 calculateGravitationalAcceleration(
    const Body& target,
    const Body& source,
    double G,
    double epsilon
) {
    // Step 1: Compute displacement vector (from target to source)
    Vec3 r = source.pos - target.pos;
    
    // Step 2: Compute squared distance
    double distSq = r.x*r.x + r.y*r.y + r.z*r.z;
    
    // Step 3: Apply softening
    // d = sqrt(r^2 + eps^2)
    double softDistSq = distSq + epsilon * epsilon;
    double softDist = std::sqrt(softDistSq);
    
    // Step 4: Compute acceleration magnitude
    // |a| = G * M / d^2
    // But we need direction, so: a = G * M * r / d^3
    // (r/d gives unit vector, then multiply by G*M/d^2)
    double magnitude = G * source.mass / (softDist * softDist * softDist);
    
    // Step 5: Return acceleration vector
    return r * magnitude;
}
\end{lstlisting}

% -----------------------------------------------------------------------------
\chapter{Barnes-Hut Multipole Acceptance Criterion}

\section{Ý tưởng Cốt lõi}

Barnes-Hut dựa trên quan sát: \textbf{Nếu một cụm sao ở đủ xa, ta có thể coi cả cụm như một điểm khối lượng duy nhất.}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=0.9]
        % Target body
        \fill[blue] (0, 0) circle (0.15);
        \node[below] at (0, -0.3) {Target $A$};

        % Far cluster (can approximate)
        \draw[thick, green!70!black] (6, 0) rectangle (8, 2);
        \fill[green!70!black] (7, 1) circle (0.2);
        \node[above] at (7, 2.2) {Cụm xa: Xấp xỉ OK};
        \node at (7, 1) {\tiny COM};

        % Near cluster (must traverse)
        \draw[thick, red!70!black] (2, -1) rectangle (4, 1);
        \fill[red] (2.5, 0.5) circle (0.1);
        \fill[red] (3.5, -0.5) circle (0.1);
        \fill[red] (3, 0) circle (0.1);
        \node[below] at (3, -1.3) {Cụm gần: Phải đi sâu};

        % Distance lines
        \draw[dashed, blue] (0, 0) -- (7, 1);
        \node[above, blue] at (3.5, 0.7) {$d$ (xa)};

        \draw[dashed, red] (0, 0) -- (3, 0);
        \node[below, red] at (1.5, -0.2) {$d$ (gần)};
    \end{tikzpicture}
    \caption{Minh họa tiêu chuẩn Barnes-Hut}
\end{figure}

\section{Tiêu chuẩn Multipole}

Gọi:
\begin{itemize}
    \item $s$ = kích thước cạnh của node Octree
    \item $d$ = khoảng cách từ target đến center of mass của node
    \item $\theta$ = tham số độ chính xác (thường chọn 0.5)
\end{itemize}

\begin{equation}
    \boxed{\text{Điều kiện xấp xỉ: } \frac{s}{d} < \theta}
\end{equation}

\begin{itemize}
    \item $\frac{s}{d} < \theta$: Node này "đủ xa" $\Rightarrow$ Dùng center of mass
    \item $\frac{s}{d} \geq \theta$: Node này "quá gần" $\Rightarrow$ Đi sâu vào con
\end{itemize}

\section{Ảnh hưởng của $\theta$}

\begin{table}[H]
    \centering
    \caption{Trade-off giữa độ chính xác và tốc độ}
    \begin{tabular}{|c|c|c|c|}
        \hline
        \textbf{$\theta$} & \textbf{Độ chính xác}     & \textbf{Tốc độ} & \textbf{Ghi chú}       \\
        \hline
        0                 & Tuyệt đối (= Brute-force) & Chậm nhất       & $O(N^2)$               \\
        0.3               & Rất cao                   & Chậm            & Scientific simulations \\
        \textbf{0.5}      & \textbf{Tốt}              & \textbf{Nhanh}  & \textbf{Khuyến nghị}   \\
        0.7               & Trung bình                & Rất nhanh       & Game/Visualization     \\
        1.0+              & Thấp                      & Nhanh nhất      & Không khuyến nghị      \\
        \hline
    \end{tabular}
\end{table}

\section{Pseudo-code Barnes-Hut}

\begin{algorithm}[H]
    \caption{Barnes-Hut calculateForce}
    \begin{algorithmic}[1]
        \Function{CalculateForce}{node, targetBody, $\theta$, $G$, $\epsilon$}
        \If{node is empty}
        \State \Return $\vec{0}$
        \EndIf

        \If{node is external AND contains a body}
        \If{body == targetBody}
        \State \Return $\vec{0}$ \Comment{Không tự hấp dẫn}
        \EndIf
        \State \Return DirectForce(targetBody, node.body, $G$, $\epsilon$)
        \EndIf

        \State $\vec{r} \gets$ node.centerOfMass $-$ targetBody.pos
        \State $d \gets |\vec{r}|$
        \State $s \gets$ node.size

        \If{$s / d < \theta$} \Comment{Multipole criterion}
        \State \Return ApproximateForce(targetBody, node.totalMass, node.centerOfMass, $G$, $\epsilon$)
        \Else
        \State $\vec{F} \gets \vec{0}$
        \For{each child in node.children}
        \State $\vec{F} \gets \vec{F} +$ \Call{CalculateForce}{child, targetBody, $\theta$, $G$, $\epsilon$}
        \EndFor
        \State \Return $\vec{F}$
        \EndIf
        \EndFunction
    \end{algorithmic}
\end{algorithm}

% -----------------------------------------------------------------------------
\chapter{Mass-based Star Coloring}

\section{Khoa học Màu sắc Sao}

Trong thiên văn học, màu sắc của ngôi sao phụ thuộc vào \textbf{nhiệt độ bề mặt}, liên quan đến khối lượng:

\begin{table}[H]
    \centering
    \caption{Phân loại Quang phổ Sao}
    \begin{tabular}{|c|c|c|c|}
        \hline
        \textbf{Loại} & \textbf{Màu}        & \textbf{Nhiệt độ (K)} & \textbf{Khối lượng (M$_\odot$)} \\
        \hline
        M             & Đỏ                  & 2,500 - 3,500         & 0.08 - 0.5                      \\
        K             & Cam                 & 3,500 - 5,000         & 0.5 - 0.8                       \\
        G             & Vàng (như Mặt Trời) & 5,000 - 6,000         & 0.8 - 1.1                       \\
        F             & Trắng-Vàng          & 6,000 - 7,500         & 1.1 - 1.5                       \\
        A             & Trắng               & 7,500 - 10,000        & 1.5 - 2.5                       \\
        B             & Xanh-Trắng          & 10,000 - 30,000       & 2.5 - 16                        \\
        O             & Xanh                & 30,000+               & 16+                             \\
        \hline
    \end{tabular}
\end{table}

\section{Thuật toán Color Mapping}

\begin{lstlisting}[language=C++, caption=Mass to Stellar Color]
/**
 * @brief Map star mass to realistic stellar color
 * @param mass The star's mass
 * @param minMass Minimum mass in simulation
 * @param maxMass Maximum mass in simulation
 * @return RGB Color
 * 
 * THUAT TOAN:
 * 1. Normalize mass to range [0, 1]
 * 2. Map to color gradient:
 *    0.0 -> Red (M-class, Red Dwarf)
 *    0.25 -> Orange (K-class)
 *    0.5 -> Yellow (G-class, like Sun)
 *    0.75 -> White (F/A-class)
 *    1.0 -> Blue (O/B-class, Blue Giant)
 */
Color massToStellarColor(double mass, double minMass, double maxMass) {
    // Step 1: Normalize to [0, 1]
    double t = (mass - minMass) / (maxMass - minMass);
    t = std::clamp(t, 0.0, 1.0);  // C++17 clamp
    
    // Step 2: Interpolate through color gradient
    // Using piecewise linear interpolation
    
    unsigned char r, g, b;
    
    if (t < 0.2) {
        // ===== RED DWARF ZONE (M-class) =====
        // Deep Red (139, 0, 0) -> Bright Red (255, 69, 0)
        double lt = t / 0.2;
        r = static_cast<unsigned char>(139 + 116 * lt);  // 139 -> 255
        g = static_cast<unsigned char>(0 + 69 * lt);      // 0 -> 69
        b = 0;
    }
    else if (t < 0.4) {
        // ===== ORANGE ZONE (K-class) =====
        // Orange-Red (255, 69, 0) -> Orange (255, 140, 0)
        double lt = (t - 0.2) / 0.2;
        r = 255;
        g = static_cast<unsigned char>(69 + 71 * lt);    // 69 -> 140
        b = 0;
    }
    else if (t < 0.6) {
        // ===== YELLOW ZONE (G-class, Sun-like) =====
        // Orange (255, 140, 0) -> Yellow (255, 255, 100)
        double lt = (t - 0.4) / 0.2;
        r = 255;
        g = static_cast<unsigned char>(140 + 115 * lt);  // 140 -> 255
        b = static_cast<unsigned char>(0 + 100 * lt);    // 0 -> 100
    }
    else if (t < 0.8) {
        // ===== WHITE ZONE (F/A-class) =====
        // Yellow-White (255, 255, 100) -> Pure White (255, 255, 255)
        double lt = (t - 0.6) / 0.2;
        r = 255;
        g = 255;
        b = static_cast<unsigned char>(100 + 155 * lt);  // 100 -> 255
    }
    else {
        // ===== BLUE ZONE (O/B-class, Blue Giant) =====
        // White (255, 255, 255) -> Blue (155, 176, 255)
        double lt = (t - 0.8) / 0.2;
        r = static_cast<unsigned char>(255 - 100 * lt);  // 255 -> 155
        g = static_cast<unsigned char>(255 - 79 * lt);   // 255 -> 176
        b = 255;
    }
    
    return Color{r, g, b, 255};
}
\end{lstlisting}

\section{Visual Size based on Mass}

Ngoài màu sắc, ta còn có thể điều chỉnh kích thước hiển thị theo khối lượng:

\begin{lstlisting}[language=C++, caption=Mass to Visual Radius]
/**
 * @brief Map mass to visual radius for rendering
 * 
 * Note: Trong thuc te, ban kinh sao ~ M^0.8 (Main Sequence)
 * Nhung de visual dep hon, ta dung logarithmic scaling
 */
float massToRadius(double mass, double minMass, double maxMass) {
    const float MIN_RADIUS = 0.03f;
    const float MAX_RADIUS = 0.3f;
    
    // Logarithmic scaling (looks better visually)
    double logMin = std::log(minMass);
    double logMax = std::log(maxMass);
    double logMass = std::log(mass);
    
    double t = (logMass - logMin) / (logMax - logMin);
    t = std::clamp(t, 0.0, 1.0);
    
    return MIN_RADIUS + static_cast<float>(t) * (MAX_RADIUS - MIN_RADIUS);
}

// Trong main loop:
void applyVisuals(std::vector<Body>& bodies) {
    // Tim min/max mass
    double minM = bodies[0].mass, maxM = bodies[0].mass;
    for (const auto& b : bodies) {
        minM = std::min(minM, b.mass);
        maxM = std::max(maxM, b.mass);
    }
    
    // Apply
    for (auto& b : bodies) {
        b.color = massToStellarColor(b.mass, minM, maxM);
        b.radius = massToRadius(b.mass, minM, maxM);
    }
}
\end{lstlisting}

% =============================================================================
% PART VI: ADVANCED FEATURES (OPTIONAL)
% =============================================================================
\part{Tính năng Nâng cao (Tùy chọn)}

\chapter{Collision Detection \& Merging}

\section{Phát hiện Va chạm}
Hiện tại các sao đi xuyên qua nhau. Để thực tế hơn:

\begin{lstlisting}[language=C++, caption=Simple Collision Detection]
/**
 * @brief Check and handle collisions between bodies
 * @param bodies Vector of all bodies
 * 
 * Note: O(N^2) - Trong production, dung spatial hashing
 */
void handleCollisions(std::vector<Body>& bodies) {
    std::vector<int> toRemove;
    
    for (size_t i = 0; i < bodies.size(); i++) {
        for (size_t j = i + 1; j < bodies.size(); j++) {
            double dist = bodies[i].pos.distance(bodies[j].pos);
            double minDist = bodies[i].radius + bodies[j].radius;
            
            if (dist < minDist) {
                // INELASTIC COLLISION: Merge into body i
                // Conservation of momentum: m1*v1 + m2*v2 = (m1+m2)*v_final
                double totalMass = bodies[i].mass + bodies[j].mass;
                
                bodies[i].vel = (bodies[i].vel * bodies[i].mass + 
                                 bodies[j].vel * bodies[j].mass) / totalMass;
                
                // Center of mass position
                bodies[i].pos = (bodies[i].pos * bodies[i].mass + 
                                 bodies[j].pos * bodies[j].mass) / totalMass;
                
                bodies[i].mass = totalMass;
                
                toRemove.push_back(j);
            }
        }
    }
    
    // Remove merged bodies (reverse order to preserve indices)
    std::sort(toRemove.begin(), toRemove.end(), std::greater<int>());
    for (int idx : toRemove) {
        bodies.erase(bodies.begin() + idx);
    }
}
\end{lstlisting}

\chapter{OpenMP Parallelization}

\section{Tối ưu hóa với Đa luồng}

\begin{lstlisting}[language=C++, caption=OpenMP Integration]
#include <omp.h>

// Chi can them 1 dong de song song hoa tinh luc!
void updateWithOpenMP(std::vector<Body>& bodies, OctreeNode* root) {
    // Parallel force calculation
    // Moi thread tinh luc cho mot nhom bodies
    #pragma omp parallel for schedule(dynamic)
    for (size_t i = 0; i < bodies.size(); i++) {
        bodies[i].acc = root->calculateForce(
            &bodies[i], THETA, G, SOFTENING
        );
    }
    
    // Parallel position update
    #pragma omp parallel for
    for (size_t i = 0; i < bodies.size(); i++) {
        bodies[i].update(DT);
    }
}

// Compile: g++ -O3 -fopenmp main.cpp -o simulation
\end{lstlisting}

\begin{tipbox}
    \textbf{Hiệu quả OpenMP:}
    \begin{itemize}
        \item 4-core CPU: Tăng tốc $\sim$3.5x
        \item 8-core CPU: Tăng tốc $\sim$6-7x
        \item Schedule \texttt{dynamic} tốt hơn \texttt{static} vì workload không đều (phụ thuộc vị trí body trong tree)
    \end{itemize}
\end{tipbox}

\chapter{Visual Effects: Trails \& Bloom}

\section{Star Trails (Vệt đuôi sao)}

\begin{lstlisting}[language=C++, caption=Simple Trail Effect]
// Luu lich su vi tri
struct Body {
    // ... existing members ...
    std::deque<Vec3> trail;  // Vi tri truoc do
    static const int TRAIL_LENGTH = 50;
    
    void updateTrail() {
        trail.push_front(pos);
        if (trail.size() > TRAIL_LENGTH) {
            trail.pop_back();
        }
    }
    
    void drawTrail() const {
        for (size_t i = 1; i < trail.size(); i++) {
            // Fade out theo vi tri
            unsigned char alpha = 255 - (255 * i / TRAIL_LENGTH);
            Color trailColor = {color.r, color.g, color.b, alpha};
            
            Vector3 start = toRaylib(trail[i-1]);
            Vector3 end = toRaylib(trail[i]);
            DrawLine3D(start, end, trailColor);
        }
    }
};
\end{lstlisting}

% =============================================================================
% CONCLUSION
% =============================================================================
\chapter{Kết luận}

\section{Những gì nhóm sẽ đạt được}

Sau 8 tuần thực hiện đồ án này, nhóm sẽ:

\begin{enumerate}
    \item \textbf{Kiến thức DSA:}
          \begin{itemize}
              \item Hiểu sâu về Con trỏ và Quản lý bộ nhớ động
              \item Thành thạo Đệ quy qua Tree traversal
              \item Nắm vững phân tích Big-O và tối ưu thuật toán
          \end{itemize}

    \item \textbf{Kỹ năng lập trình:}
          \begin{itemize}
              \item Viết C++ sạch theo Modern conventions
              \item Sử dụng thư viện đồ họa (Raylib)
              \item Debug và optimize code hiệu quả
          \end{itemize}

    \item \textbf{Kiến thức khoa học:}
          \begin{itemize}
              \item Hiểu vật lý Newton và mô phỏng số
              \item Biết về thiên văn học cơ bản (màu sao, cấu trúc thiên hà)
          \end{itemize}

    \item \textbf{Sản phẩm:}
          \begin{itemize}
              \item Một mô phỏng vũ trụ 3D đẹp mắt
              \item Portfolio project ấn tượng cho CV
          \end{itemize}
\end{enumerate}

\section{Lời khuyên cuối cùng}

\begin{importantbox}
    \begin{enumerate}
        \item \textbf{Đừng sợ sai:} Bugs là thầy giáo tốt nhất. Mỗi Segmentation Fault dạy bạn về pointers.
        \item \textbf{Commit thường xuyên:} Dùng Git, commit mỗi khi hoàn thành một feature nhỏ.
        \item \textbf{Visual debugging:} Vẽ Octree wireframe giúp debug cực kỳ hiệu quả.
        \item \textbf{Incremental development:} Brute-force trước, Barnes-Hut sau. Đừng cố làm tất cả cùng lúc.
        \item \textbf{Hỏi khi cần:} Stack Overflow, GitHub Issues, và thầy/cô luôn sẵn sàng giúp đỡ.
    \end{enumerate}
\end{importantbox}

\vspace{1cm}
\begin{center}
    \textit{"The cosmos is within us. We are made of star-stuff."}\\
    — Carl Sagan
\end{center}

\vspace{2cm}
\begin{center}
    \textbf{LET'S BUILD THIS UNIVERSE!}
\end{center}

\end{document}